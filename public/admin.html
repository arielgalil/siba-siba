<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>× ×™×”×•×œ ×©×¨×©×¨×ª ×”×¡×™×‘×•×ª â›“ï¸â€ğŸ’¥</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Style for the import container */
      #importContainer {
        transition: max-height 0.5s ease-out, opacity 0.5s ease-out,
          padding 0.5s ease-out, border-width 0.5s ease-out;
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        padding-top: 0;
        padding-bottom: 0;
        border-width: 0;
      }
      #importContainer.visible {
        max-height: 500px; /* Adjust as needed */
        opacity: 1;
        padding-top: 1rem;
        padding-bottom: 1rem;
        padding-left: 1rem;
        padding-right: 1rem;
        border-width: 1px;
      }
      /* Ensure textarea respects dark mode */
      textarea {
        color-scheme: light dark;
      }
      /* Prevent number input spinner */
      input[type="number"]::-webkit-inner-spin-button,
      input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type="number"] {
        -moz-appearance: textfield; /* Firefox */
      }
      /* Style disabled elements more clearly */
      button:disabled,
      input:disabled,
      select:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }
      select:disabled {
        background-color: #e5e7eb; /* Tailwind gray-200 */
      }
      .dark select:disabled {
        background-color: #4b5563; /* Tailwind gray-600 */
      }
       /* Style for validation errors in import */
      #importStatus.error {
          color: #dc2626; /* Tailwind red-600 */
          font-weight: bold;
      }
       .dark #importStatus.error {
           color: #f87171; /* Tailwind red-400 */
       }
    </style>
  </head>
  <body
    class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 p-6 flex flex-col items-center"
  >
    <h1 class="text-3xl font-bold mb-4 text-center">
      × ×™×”×•×œ ×©×¨×©×¨×ª ×”×¡×™×‘×•×ª â›“ï¸â€ğŸ’¥
    </h1>
    <div
      id="status"
      class="mb-4 text-center text-sm text-gray-600 dark:text-gray-400 min-h-[1em]"
    >
      ×˜×•×¢×Ÿ...
    </div>

    <div class="mb-4 flex flex-wrap gap-2 justify-center">
      <button
        id="googleSignInBtn"
        class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
      >
        ×”×ª×—×‘×¨ ×‘×’×•×’×œ
      </button>
      <button
        id="newGroupBtn"
        class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 hidden"
      >
        â• ×”×•×¡×£ ×§×‘×•×¦×”
      </button>
      <button
        id="deleteGroupBtn"
        class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 hidden"
        disabled
      >
        ğŸ—‘ï¸ ××—×§ ×§×‘×•×¦×” × ×•×›×—×™×ª
      </button>
      <button
        id="importBtn"
        class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 hidden"
      >
        ğŸ“œ ×™×™×‘× ×§×‘×•×¦×•×ª
      </button>
      <button
        id="exportBtn"
        class="px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700 hidden"
        disabled
      >
        ğŸ“¤ ×™×¦× ×”×›×œ
      </button>
    </div>

    <div
      id="importContainer"
      class="w-full max-w-xl p-4 border rounded-lg bg-gray-100 dark:bg-gray-800 mb-4"
    >
      <h3 class="text-lg font-semibold mb-2">×™×™×‘×•× ×§×‘×•×¦×•×ª ××˜×§×¡×˜</h3>
      <p class="text-sm mb-2 text-gray-600 dark:text-gray-400">
        ××‘× ×”: ×©×•×¨×ª × ×•×©×, ×©×•×¨×ª ×¨××ª ×§×•×©×™ (1-5), ×©×•×¨×•×ª ××©×¤×˜×™× (×¢× '*' ×œ× ×¢×•×œ), ×©×•×¨×”
        ×¨×™×§×” ×‘×™×Ÿ ×§×‘×•×¦×•×ª.
      </p>
      <textarea
        id="importText"
        rows="10"
        class="w-full p-2 border rounded bg-white dark:bg-gray-700 mb-2"
        placeholder="× ×•×©× ×”×§×‘×•×¦×” ×”×¨××©×•× ×”
3
××©×¤×˜ ×
*××©×¤×˜ ×‘ (× ×¢×•×œ)

× ×•×©× ×”×§×‘×•×¦×” ×”×©× ×™×™×”
1
*××©×¤×˜ ×’ (× ×¢×•×œ)
××©×¤×˜ ×“"
      ></textarea>
      <button
        id="submitImportBtn"
        class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700"
      >
        ×‘×¦×¢ ×™×™×‘×•×
      </button>
      <div
        id="importStatus"
        class="mt-2 text-sm text-gray-600 dark:text-gray-400"
      ></div>
    </div>

     <div class="mb-4 w-full max-w-xl">
      <input
        type="search"
        id="searchInput"
        placeholder="×—×™×¤×•×© ×œ×¤×™ ×˜×§×¡×˜ ×‘× ×•×©× ××• ×‘××©×¤×˜×™×..."
        class="w-full p-2 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
        disabled
      />
    </div>
    <div
      class="mb-6 flex flex-wrap gap-4 justify-center items-center w-full max-w-xl"
    >
      <label class="block whitespace-nowrap">
        ×¡×™× ×•×Ÿ × ×•×©×:
        <select
          id="topicFilter"
          class="p-1 border rounded bg-white dark:bg-gray-700"
          disabled
        >
          <option value="all">×”×›×œ</option>
          </select>
      </label>
      <label class="block whitespace-nowrap">
        ×¡×™× ×•×Ÿ ×¨××”:
        <select
          id="difficultyFilter"
          class="p-1 border rounded bg-white dark:bg-gray-700"
          disabled
        >
          <option value="all">×”×›×œ</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
        </select>
      </label>
      <button
        id="clearFiltersBtn"
        class="px-3 py-1 bg-gray-400 text-black rounded hover:bg-gray-500"
        disabled
      >
        × ×§×” ×¡×™× ×•× ×™×
      </button>
    </div>

    <div class="flex items-center mb-6 space-x-2 space-x-reverse">
      <button
        id="prevBtn"
        class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg"
        disabled
      >
        ×”×§×•×“×
      </button>
      <input
        id="groupInput"
        type="number"
        min="0"
        value="0"
        class="w-16 px-2 py-1 border rounded-lg text-center bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
        disabled
      />
      <span id="groupCount" class="text-gray-600 dark:text-gray-400">/ 0</span>
      <button
        id="nextBtn"
        class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg"
        disabled
      >
        ×”×‘×
      </button>
    </div>

    <div id="group-container" class="w-full max-w-xl min-h-[200px]">
      <p class="text-center text-gray-500 dark:text-gray-400">
        ×˜×•×¢×Ÿ × ×ª×•× ×™×...
      </p>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
        onAuthStateChanged,
        GoogleAuthProvider,
        signInWithPopup,
        setPersistence,
        browserLocalPersistence,
      } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-auth.js";
      import {
        getDatabase,
        ref,
        onValue,
        update,
        set,
        remove,
        child,
        get,
      } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-database.js";

      // --- Firebase Configuration ---
      const firebaseConfig = {
        apiKey: "AIzaSyAGFC_TB8iEMvS2PyxeASj1HH4i66AW4UA", // Replace with your actual API key if needed
        authDomain: "trivbio.firebaseapp.com",
        databaseURL: "https://trivbio-default-rtdb.firebaseio.com",
        projectId: "trivbio",
        storageBucket: "trivbio.appspot.com",
        messagingSenderId: "1097087574583",
        appId: "1:1097087574583:web:b36c0441537a1f596215b2",
        measurementId: "G-ZY245YB23E",
      };
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getDatabase(app);
      const groupsRef = ref(db, "collections/groups");

      // --- DOM Element References ---
      const statusEl = document.getElementById("status");
      const googleBtn = document.getElementById("googleSignInBtn");
      const newBtn = document.getElementById("newGroupBtn");
      const delBtn = document.getElementById("deleteGroupBtn");
      const importBtn = document.getElementById("importBtn");
      const exportBtn = document.getElementById("exportBtn"); // New export button
      const importContainer = document.getElementById("importContainer");
      const importText = document.getElementById("importText");
      const submitImportBtn = document.getElementById("submitImportBtn");
      const importStatusEl = document.getElementById("importStatus");
      const container = document.getElementById("group-container");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const groupInp = document.getElementById("groupInput");
      const groupCountEl = document.getElementById("groupCount");
      const searchInput = document.getElementById("searchInput");
      const topicFilter = document.getElementById("topicFilter");
      const difficultyFilter = document.getElementById("difficultyFilter");
      const clearFiltersBtn = document.getElementById("clearFiltersBtn");

      // --- Global State Variables ---
      const TOPICS = ["×›×œ×œ×™", "×”×ª×", "×’×•×£ ×”××“×", "××§×•×œ×•×’×™×”", "××¢×‘×“×”"];
      let allGroups = [];
      let filteredGroups = [];
      let originalIdx = -1; // The originalIndex of the item being edited
      let filteredIdx = 0;
      let admin = false;
      let edit = false;
      let isAddingNewGroup = false;
      let newGroupDataBuffer = null;
      let currentAuthUser = null;
      let currentSearchTerm = "";
      let currentTopicFilter = "all";
      let currentDifficultyFilter = "all";
      let focusOnOriginalIndexAfterUpdate = -1; // Flag to restore view after edit

      // --- Initialization ---
      const topicOptionsHTML = TOPICS.map(
        (t) => `<option value="${t}">${t}</option>`
      ).join("");
      topicFilter.innerHTML += topicOptionsHTML;

      // --- Authentication Setup ---
      function initializeAuthListener() {
        onAuthStateChanged(auth, (u) => {
          currentAuthUser = u;
          if (u) {
            const isGoogleSignIn = u.providerData.some(
              (p) => p.providerId === "google.com"
            );
            if (isGoogleSignIn) {
              googleBtn.classList.add("hidden");
              statusEl.innerText = `××—×•×‘×¨: ${u.email}`;
              checkAdminStatus(u.uid); // Checks admin then calls listenForGroups
            } else {
              googleBtn.classList.remove("hidden");
              statusEl.innerText =
                "××—×•×‘×¨ ×× ×•× ×™××™×ª. ×”×ª×—×‘×¨ ×¢× ×’×•×’×œ ×œ× ×™×”×•×œ.";
              admin = false; // Anonymous is not admin
              updateAdminUI();
              listenForGroups(); // Listen for data as anonymous user
            }
          } else {
            googleBtn.classList.remove("hidden");
            statusEl.innerText = "××™× ×š ××—×•×‘×¨. ×”×ª×—×‘×¨ ×¢× ×’×•×’×œ ×œ× ×™×”×•×œ.";
            admin = false;
            updateAdminUI();
            allGroups = []; // Clear data
            edit = false;
            isAddingNewGroup = false;
            applyFiltersAndSearch(); // Render empty state
          }
        });
      }

      setPersistence(auth, browserLocalPersistence)
        .then(() => {
          console.log("Firebase Auth persistence set to local.");
          initializeAuthListener();
        })
        .catch((error) => {
          console.error("Error setting Firebase Auth persistence:", error);
          statusEl.innerText =
            "×©×’×™××” ×‘×”×’×“×¨×ª ×©××™×¨×ª ×”×ª×—×‘×¨×•×ª. ×™×™×ª×›×Ÿ ×©×ª×¦×˜×¨×š ×œ×”×ª×—×‘×¨ ×©×•×‘.";
          initializeAuthListener();
        });

      const provider = new GoogleAuthProvider();
      googleBtn.onclick = () =>
        signInWithPopup(auth, provider).catch(
          (e) => (statusEl.innerText = "×©×’×™××ª ×”×ª×—×‘×¨×•×ª ×’×•×’×œ: " + e.message)
        );

      function checkAdminStatus(uid) {
        const adminRef = ref(db, `admins/${uid}`);
        get(adminRef)
          .then((snapshot) => {
            admin = snapshot.exists() && snapshot.val() === true;
            updateAdminUI();
            if (!admin && statusEl.innerText.startsWith("××—×•×‘×¨:")) {
              statusEl.innerText += " (×œ× ×× ×”×œ)";
            }
            listenForGroups(); // Listen *after* confirming admin status
          })
          .catch((error) => {
            console.error("Error checking admin status:", error);
            admin = false;
            updateAdminUI();
            listenForGroups(); // Assume not admin, but still listen
          });
      }

      function updateAdminUI() {
        if (admin) {
          newBtn.classList.remove("hidden");
          delBtn.classList.remove("hidden");
          importBtn.classList.remove("hidden");
          exportBtn.classList.remove("hidden"); // Show export button for admin
        } else {
          newBtn.classList.add("hidden");
          delBtn.classList.add("hidden");
          importBtn.classList.add("hidden");
          exportBtn.classList.add("hidden"); // Hide export button if not admin
          importContainer.classList.remove("visible");
          if (edit) {
            cancelEditOrAdd();
          }
        }
        render();
        updateNav();
      }

      // --- Data Handling ---
      function listenForGroups() {
        onValue(
          groupsRef,
          (snap) => {
            const groupsData = snap.val();
            let processedGroups = [];
            if (groupsData) {
              if (Array.isArray(groupsData)) {
                processedGroups = groupsData
                  .map((group, index) =>
                    group && typeof index === "number" && !isNaN(index)
                      ? { ...group, originalIndex: index }
                      : null
                  )
                  .filter((group) => group !== null);
              } else if (typeof groupsData === "object") {
                processedGroups = Object.entries(groupsData)
                  .map(([key, group]) => {
                    const index = parseInt(key, 10);
                    return group && !isNaN(index)
                      ? { ...group, originalIndex: index }
                      : null;
                  })
                  .filter((group) => group !== null)
                  .sort((a, b) => a.originalIndex - b.originalIndex);
              }
            }
            allGroups = processedGroups;

            if ((edit || isAddingNewGroup) && allGroups.length === 0) {
              cancelEditOrAdd();
            }

            applyFiltersAndSearch(); // Apply filters first

            // Focus/Restore Logic (unchanged)
            if (focusOnOriginalIndexAfterUpdate !== -1) {
              const targetFilteredIndex = filteredGroups.findIndex(
                (g) => g.originalIndex === focusOnOriginalIndexAfterUpdate
              );
              if (targetFilteredIndex !== -1) {
                filteredIdx = targetFilteredIndex;
              } else {
                filteredIdx = Math.max(0, filteredGroups.length - 1);
                if (filteredGroups.length === 0) filteredIdx = 0;
              }
              focusOnOriginalIndexAfterUpdate = -1;
            } else if (!edit) {
              let currentlyViewedOriginalIndex = -1;
              if (
                filteredGroups.length > 0 &&
                filteredIdx >= 0 &&
                filteredIdx < filteredGroups.length &&
                filteredGroups[filteredIdx]?.originalIndex !== undefined
              ) {
                currentlyViewedOriginalIndex =
                  filteredGroups[filteredIdx].originalIndex;
              }
              if (currentlyViewedOriginalIndex !== -1) {
                const restoredFilteredIndex = filteredGroups.findIndex(
                  (g) => g.originalIndex === currentlyViewedOriginalIndex
                );
                if (restoredFilteredIndex !== -1) {
                  filteredIdx = restoredFilteredIndex;
                } else {
                  filteredIdx = Math.max(0, filteredGroups.length - 1);
                  if (filteredGroups.length === 0) filteredIdx = 0;
                }
              } else {
                filteredIdx = Math.max(0, filteredGroups.length - 1);
                if (filteredGroups.length === 0) filteredIdx = 0;
              }
            }

            updateStatusMessage();
            render();
            updateNav();
          },
          (error) => {
            console.error("Error fetching groups:", error);
            statusEl.innerText = "×©×’×™××” ×‘×§×¨×™××ª × ×ª×•× ×™×.";
            allGroups = [];
            edit = false;
            isAddingNewGroup = false;
            applyFiltersAndSearch();
            updateStatusMessage();
            render();
            updateNav();
          }
        );
      }

      function updateStatusMessage() {
        if (edit) {
          statusEl.innerText = isAddingNewGroup
            ? "××™×œ×•×™ ×¤×¨×˜×™ ×§×‘×•×¦×” ×—×“×©×”..."
            : `×¢×¨×™×›×ª ×§×‘×•×¦×”...`;
          return;
        }
        if (allGroups.length === 0) {
          statusEl.innerText = admin
            ? "××™×Ÿ ×§×‘×•×¦×•×ª. ×”×•×¡×£ ××• ×™×™×‘×."
            : "××™×Ÿ ×§×‘×•×¦×•×ª ×œ×”×¦×’×”.";
        } else if (filteredGroups.length === 0) {
          statusEl.innerText = `×œ× × ××¦××• ×§×‘×•×¦×•×ª ×‘×¡×™× ×•×Ÿ ××ª×•×š ${allGroups.length}.`;
        } else {
          statusEl.innerText = `××¦×™×’ ${filteredGroups.length} ××ª×•×š ${allGroups.length} (${
            filteredIdx + 1
          }/${filteredGroups.length})`;
        }
      }

      // --- Filtering and Searching ---
      function applyFiltersAndSearch() {
        const searchTerm = currentSearchTerm.toLowerCase();
        filteredGroups = allGroups.filter((group) => {
          if (
            !group ||
            !group.sentences ||
            !Array.isArray(group.sentences) ||
            typeof group.originalIndex !== "number"
          ) {
            return false;
          }
          const diffMatch =
            currentDifficultyFilter === "all" ||
            group.difficulty == currentDifficultyFilter;
          const topicMatch =
            currentTopicFilter === "all" ||
            (group.topic || "×›×œ×œ×™") === currentTopicFilter;
          const searchMatch =
            searchTerm === "" ||
            (group.topic || "").toLowerCase().includes(searchTerm) ||
            group.sentences.some(
              (s) => s && s.text && s.text.toLowerCase().includes(searchTerm)
            );
          return diffMatch && topicMatch && searchMatch;
        });
      }

      // --- Event Listeners for Search/Filter ---
      searchInput.addEventListener("input", () => {
        if (edit) return;
        currentSearchTerm = searchInput.value;
        applyFiltersAndSearch();
        filteredIdx = 0;
        render();
        updateNav();
        updateStatusMessage();
      });
      topicFilter.addEventListener("change", () => {
        if (edit) return;
        currentTopicFilter = topicFilter.value;
        applyFiltersAndSearch();
        filteredIdx = 0;
        render();
        updateNav();
        updateStatusMessage();
      });
      difficultyFilter.addEventListener("change", () => {
        if (edit) return;
        currentDifficultyFilter = difficultyFilter.value;
        applyFiltersAndSearch();
        filteredIdx = 0;
        render();
        updateNav();
        updateStatusMessage();
      });
      clearFiltersBtn.addEventListener("click", () => {
        if (edit) return;
        searchInput.value = "";
        topicFilter.value = "all";
        difficultyFilter.value = "all";
        currentSearchTerm = "";
        currentTopicFilter = "all";
        currentDifficultyFilter = "all";
        applyFiltersAndSearch();
        filteredIdx = 0;
        render();
        updateNav();
        updateStatusMessage();
      });

      // --- Group Actions ---
      newBtn.onclick = () => {
        if (!admin || edit) return;
        edit = true;
        isAddingNewGroup = true;
        newGroupDataBuffer = {
          difficulty: 1,
          topic: "×›×œ×œ×™",
          sentences: [{ text: "", movable: true }],
        };
        originalIdx = -1;
        render();
        updateNav();
        updateStatusMessage();
      };
      delBtn.onclick = () => {
        if (!admin || edit || filteredGroups.length === 0) return;
        const groupToDelete = filteredGroups[filteredIdx];
        if (
          !groupToDelete ||
          typeof groupToDelete.originalIndex !== "number"
        ) {
          statusEl.innerText = "×©×’×™××” ×‘×–×™×”×•×™ ×§×‘×•×¦×”.";
          return;
        }
        const idxToDelete = groupToDelete.originalIndex;
        if (
          !confirm(
            `×œ××—×•×§ ××ª ×§×‘×•×¦×” "${groupToDelete.topic || "×›×œ×œ×™"} - ×¨××” ${
              groupToDelete.difficulty
            }"?`
          )
        )
          return;
        statusEl.innerText = "××•×—×§...";
        remove(ref(db, `collections/groups/${idxToDelete}`))
          .then(() => {
            statusEl.innerText = "× ××—×§";
            // Adjust index if deleting the last filtered item
            if (filteredIdx >= filteredGroups.length) {
               filteredIdx = Math.max(0, filteredGroups.length - 1);
            }
          })
          .catch((e) => {
            statusEl.innerText = "×©×’×™××” ×‘××—×™×§×”: " + e.message;
          });
      };

      // --- Import/Export Logic ---
      importBtn.onclick = () => {
        if (!admin || edit) return;
        importContainer.classList.toggle("visible");
        importStatusEl.innerText = "";
        importStatusEl.classList.remove("error"); // Clear error state
        importText.value = "";
        if (importContainer.classList.contains("visible") && edit) {
          cancelEditOrAdd();
        }
      };

      exportBtn.onclick = () => { // New export handler
          if (!admin || edit || allGroups.length === 0) return;
          exportGroups(allGroups);
      };

      submitImportBtn.onclick = () => {
        if (!admin) return;
        const text = importText.value.trim();
        importStatusEl.classList.remove("error"); // Clear previous error state
        if (!text) {
          importStatusEl.innerText = "×ª×™×‘×ª ×˜×§×¡×˜ ×¨×™×§×”.";
          return;
        }
        importStatusEl.innerText = "××¢×‘×“...";
        const parsed = parseImportText(text);
        if (parsed.error) {
          importStatusEl.innerText = `×©×’×™××ª × ×™×ª×•×—: ${parsed.error}`;
          importStatusEl.classList.add("error"); // Add error styling
          return;
        }
        if (parsed.groups.length === 0) {
          importStatusEl.innerText = "×œ× × ××¦××• ×§×‘×•×¦×•×ª ×ª×§×™× ×•×ª ×œ×™×™×‘×•×.";
          return;
        }
        importGroupsToFirebase(parsed.groups);
      };

      function parseImportText(text) {
        const blocks = text.split(/\n\s*\n/); // Split by one or more empty lines
        const newGroups = [];
        let error = null;

        blocks.forEach((block, blockIndex) => {
          if (error) return; // Stop if error found
          const lines = block.trim().split("\n").map((l) => l.trim());
          const nonEmptyLines = lines.filter(l => l); // Filter out fully empty lines within a block

          // Basic structure check: Need at least topic, difficulty, and one sentence
          if (nonEmptyLines.length < 3) {
             if (nonEmptyLines.length > 0) { // Only report error if the block wasn't just whitespace
                error = `×‘×œ×•×§ ${blockIndex + 1}: ×œ× ×ª×§×™×Ÿ. ×—×™×™×‘ ×œ×”×›×™×œ ×œ×¤×—×•×ª × ×•×©×, ×¨××ª ×§×•×©×™ ×•××©×¤×˜ ××—×“.`;
             }
            return;
          }

          // Topic (Line 1)
          const topicLine = nonEmptyLines[0];
          const topic = TOPICS.includes(topicLine) ? topicLine : "×›×œ×œ×™"; // Default to '×›×œ×œ×™' if not recognized

          // Difficulty (Line 2) - **Validation Added**
          const difficultyLine = nonEmptyLines[1];
          const parsedDifficulty = parseInt(difficultyLine, 10);
          let difficulty;
          if (
            isNaN(parsedDifficulty) ||
            parsedDifficulty < 1 ||
            parsedDifficulty > 5
          ) {
            error = `×‘×œ×•×§ ${blockIndex + 1} ("${topicLine}"): ×¨××ª ×§×•×©×™ (${difficultyLine}) ×—×™×™×‘×ª ×œ×”×™×•×ª ××¡×¤×¨ ×‘×™×Ÿ 1 ×œ-5.`;
            return;
          } else {
             difficulty = parsedDifficulty;
          }

          // Sentences (Lines 3+) - **Validation Added**
          const sentences = nonEmptyLines
            .slice(2)
            .map((line) => {
              const isLocked = line.startsWith("*");
              const text = isLocked ? line.substring(1).trim() : line.trim(); // Trim whitespace
              if (!text) return null; // Ignore lines that become empty after removing '*' or trimming
              return { text: text, movable: !isLocked };
            })
            .filter((s) => s !== null); // Remove nulls (empty sentences)

          if (sentences.length === 0) {
            error = `×‘×œ×•×§ ${blockIndex + 1} ("${topicLine}"): ×œ× × ××¦××• ××©×¤×˜×™× ×ª×§×™× ×™×.`;
            return;
          }

          newGroups.push({
            difficulty: difficulty,
            topic: topic,
            sentences: sentences,
          });
        });

        return { groups: newGroups, error: error };
      }

      async function importGroupsToFirebase(parsedGroups) {
        if (!admin) return;
        importStatusEl.innerText = `××™×™×‘× ${parsedGroups.length}...`;
        try {
          const validIndices = allGroups
            .map((g) => g.originalIndex)
            .filter((idx) => typeof idx === "number" && !isNaN(idx));
          const nextIdx =
            validIndices.length > 0 ? Math.max(...validIndices) + 1 : 0;
          if (isNaN(nextIdx)) {
            throw new Error("Could not determine next index.");
          }
          const updates = {};
          parsedGroups.forEach((group, i) => {
            const newIdx = nextIdx + i;
            // Ensure originalIndex is added for consistency, even though not strictly needed by Firebase update itself here
            updates[newIdx] = { ...group, originalIndex: newIdx };
          });
          if (Object.keys(updates).length > 0) {
            await update(ref(db, "collections/groups"), updates);
            importStatusEl.innerText = `×™×™×‘×•× ×”×•×©×œ×! × ×•×¡×¤×• ${parsedGroups.length} ×§×‘×•×¦×•×ª.`;
            importStatusEl.classList.remove("error");
            importText.value = "";
            importContainer.classList.remove("visible");
          } else {
            importStatusEl.innerText = "×œ× × ××¦××• ×§×‘×•×¦×•×ª ×œ×™×™×‘×.";
             importStatusEl.classList.remove("error");
          }
        } catch (e) {
          console.error("Import error:", e);
          importStatusEl.innerText = "×©×’×™××” ×‘×™×™×‘×•×: " + e.message;
          importStatusEl.classList.add("error");
        }
      }

       // --- Export Function ---
      function exportGroups(groupsToExport) {
          if (!groupsToExport || groupsToExport.length === 0) {
              statusEl.innerText = "××™×Ÿ ×§×‘×•×¦×•×ª ×œ×™×™×¦×.";
              return;
          }

          let exportText = "";
          groupsToExport.forEach((group, index) => {
              if (!group || !group.sentences || !Array.isArray(group.sentences)) {
                  console.warn("Skipping invalid group during export:", group);
                  return;
              }
              exportText += group.topic || "×›×œ×œ×™"; // Use '×›×œ×œ×™' if topic is missing
              exportText += "\n";
              exportText += group.difficulty || 1; // Use 1 if difficulty is missing
              exportText += "\n";
              group.sentences.forEach(sentence => {
                   if (sentence && sentence.text) {
                      exportText += (sentence.movable === false ? "*" : "") + sentence.text;
                      exportText += "\n";
                   }
              });
              // Add empty line between groups, but not after the last one
              if (index < groupsToExport.length - 1) {
                  exportText += "\n";
              }
          });

          // Create a blob and trigger download
          const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
          const link = document.createElement("a");
          const url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          link.setAttribute("download", "exported_question_groups.txt");
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url); // Clean up
          statusEl.innerText = "×”×§×‘×•×¦×•×ª ×™×•×¦××• ×œ×§×•×‘×¥.";
           // Optionally hide status message after a delay
           setTimeout(() => { if (statusEl.innerText === "×”×§×‘×•×¦×•×ª ×™×•×¦××• ×œ×§×•×‘×¥.") updateStatusMessage(); }, 3000);
      }


      // --- Rendering Logic ---
      const rowHTML = (text, locked) =>
        ` <div class="sentence-row flex items-center space-x-2 space-x-reverse mb-2"><input type="text" value="${
          text || ""
        }" class="sentence-input flex-1 p-2 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100" placeholder="×”×–×Ÿ ××©×¤×˜ ×›××Ÿ" /><label class="inline-flex items-center space-x-1 space-x-reverse" title="× ×¢×œ ××©×¤×˜"><input type="checkbox" ${
          locked ? "checked" : ""
        } class="lock-checkbox h-5 w-5 accent-blue-500" /><span>ğŸ”’</span></label><button type="button" class="removeSentence text-red-500 hover:text-red-700 font-bold text-lg" title="××—×§ ××©×¤×˜">âœ–ï¸</button></div>`;

      function view(g) {
        if (!g || typeof g.originalIndex !== "number")
          return '<p class="text-red-500 dark:text-red-400">×©×’×™××” ×‘× ×ª×•× ×™×.</p>';
        const topic = g.topic || "×›×œ×œ×™";
        const diff = g.difficulty || "?";
        const title = `${topic} - ×¨××” ${diff}`;
        const editBtn = admin
          ? `<button data-original-idx="${g.originalIndex}" id="editBtn" class="absolute top-2 left-2 text-gray-500 hover:text-gray-800 dark:hover:text-gray-200 text-xl" title="×¢×¨×•×š">âœï¸</button>`
          : "";
        return `<div class="border rounded-2xl shadow-lg p-4 bg-gray-50 dark:bg-gray-800 relative">${editBtn}<h2 class="text-2xl font-semibold mb-4">${title}</h2><h3 class="text-lg font-semibold mb-2">××©×¤×˜×™×:</h3><ol class="list-decimal list-outside mr-5 space-y-1"> ${
          g.sentences && Array.isArray(g.sentences) && g.sentences.length > 0
            ? g.sentences
                .map(
                  (s) =>
                    `<li>${s.text || "(×¨×™×§)"}${
                      !s.movable
                        ? ' <span class="text-sm text-green-600 dark:text-green-400" title="× ×¢×•×œ">ğŸ”’</span>'
                        : ""
                    }</li>`
                )
                .join("")
            : "<li>××™×Ÿ ××©×¤×˜×™×.</li>"
        }</ol></div>`;
      }

      function editForm(g) {
        const data = isAddingNewGroup ? newGroupDataBuffer : g;
        if (!data) {
          return '<p class="text-red-500 dark:text-red-400">×©×’×™××” ×‘×”×¦×’×ª ×˜×•×¤×¡.</p>';
        }
        const rows = (data.sentences || [])
          .map((s) => rowHTML(s.text || "", !s.movable))
          .join("");
        const topic = data.topic || "×›×œ×œ×™";
        const title = isAddingNewGroup ? "×”×•×¡×¤×ª ×§×‘×•×¦×” ×—×“×©×”" : `×¢×¨×™×›×ª ×§×‘×•×¦×”`;
        return `<div class="border rounded-2xl shadow-lg p-4 bg-gray-50 dark:bg-gray-800"><h2 class="text-2xl font-semibold mb-2">${title}</h2><form id="editForm" class="space-y-3"><div class="flex flex-wrap gap-4 items-center mb-4"><label class="block">×¨××ª ×§×•×©×™: <input id="diffInput" type="number" value="${
          data.difficulty || 1
        }" min="1" max="5" class="p-1 border rounded bg-white dark:bg-gray-700 w-16 text-gray-900 dark:text-gray-100" /></label><label class="block">× ×•×©×: <select id="topicInput" class="p-1 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">${TOPICS.map(
          (t) => `<option value="${t}" ${t === topic ? "selected" : ""}>${t}</option>`
        ).join(
          ""
        )}</select></label></div><div id="sentences-container"><h3 class="text-lg font-semibold mb-2">××©×¤×˜×™×:</h3>${rows}</div><button type="button" id="addSentence" class="mt-2 px-3 py-1 bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 rounded text-gray-900 dark:text-gray-100">â• ×”×•×¡×£ ××©×¤×˜</button><div class="flex justify-between mt-4"><button type="button" id="cancelBtn" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">×‘×™×˜×•×œ</button><button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">×©××•×¨ ×•×¡×’×•×¨</button></div></form></div>`;
      }

      function render() {
        container.innerHTML = "";
        if (edit) {
          if (isAddingNewGroup) {
            container.innerHTML = editForm(null);
          } else {
            const groupToEdit = allGroups.find(
              (g) => g.originalIndex === originalIdx
            );
            if (groupToEdit) {
              container.innerHTML = editForm(groupToEdit);
            } else {
              console.error(
                `Render error: Group ${originalIdx} not found.`
              );
              statusEl.innerText = "×©×’×™××”: ×§×‘×•×¦×” ×œ×¢×¨×™×›×” ×œ× × ××¦××”.";
              cancelEditOrAdd();
            }
          }
        } else {
          if (
            filteredGroups.length > 0 &&
            filteredIdx < filteredGroups.length
          ) {
            const groupToView = filteredGroups[filteredIdx];
            if (groupToView && typeof groupToView.originalIndex === "number") {
              container.innerHTML = view(groupToView);
            } else {
              console.error(
                "Render view error: Invalid group data",
                filteredIdx,
                groupToView
              );
              container.innerHTML =
                '<p class="text-red-500 dark:text-red-400">×©×’×™××” ×‘×”×¦×’×”.</p>';
            }
          } else {
            const hasFilters =
              currentSearchTerm ||
              currentTopicFilter !== "all" ||
              currentDifficultyFilter !== "all";
            container.innerHTML =
              allGroups.length === 0
                ? admin
                  ? '<p class="text-gray-500 dark:text-gray-400">××™×Ÿ ×§×‘×•×¦×•×ª. ×”×•×¡×£ ××• ×™×™×‘×.</p>'
                  : '<p class="text-gray-500 dark:text-gray-400">××™×Ÿ ×§×‘×•×¦×•×ª ×œ×”×¦×’×”.</p>'
                : hasFilters
                ? '<p class="text-gray-500 dark:text-gray-400">×œ× × ××¦××• ×§×‘×•×¦×•×ª ×‘×¡×™× ×•×Ÿ ×–×”.</p>'
                : '<p class="text-gray-500 dark:text-gray-400">×˜×•×¢×Ÿ...</p>';
          }
        }
      }

      // --- Navigation ---
      function updateNav() {
        const totalFiltered = filteredGroups.length;
        const displayTotal = totalFiltered;
        const displayIdx = filteredIdx;
        const disableNav = edit || totalFiltered === 0;
        const disableFilters = edit;
        const disableAdminActions = !admin || edit; // Consolidated admin action disable logic

        prevBtn.disabled = disableNav || displayIdx <= 0;
        nextBtn.disabled = disableNav || displayIdx >= displayTotal - 1;
        groupInp.disabled = disableNav;
        searchInput.disabled = disableFilters;
        topicFilter.disabled = disableFilters;
        difficultyFilter.disabled = disableFilters;
        clearFiltersBtn.disabled = disableFilters;

        groupInp.value = totalFiltered === 0 ? 0 : displayIdx + 1;
        groupInp.max = displayTotal > 0 ? displayTotal : 1;
        groupInp.min = totalFiltered > 0 ? 1 : 0;
        groupCountEl.innerText = `/ ${displayTotal}`;

        // Admin buttons
        delBtn.disabled = disableAdminActions || totalFiltered === 0; // Also disable if no groups to delete
        newBtn.disabled = disableAdminActions;
        importBtn.disabled = disableAdminActions;
        exportBtn.disabled = disableAdminActions || allGroups.length === 0; // Disable export if no groups exist at all
      }
      prevBtn.onclick = () => {
        if (!edit && filteredIdx > 0) {
          filteredIdx--;
          render();
          updateNav();
          updateStatusMessage();
        }
      };
      nextBtn.onclick = () => {
        if (!edit && filteredIdx < filteredGroups.length - 1) {
          filteredIdx++;
          render();
          updateNav();
          updateStatusMessage();
        }
      };
      groupInp.onchange = (e) => {
        if (edit) return;
        const v = +e.target.value - 1;
        if (v >= 0 && v < filteredGroups.length) {
          filteredIdx = v;
          render();
          updateNav();
          updateStatusMessage();
        } else {
          e.target.value = filteredGroups.length > 0 ? filteredIdx + 1 : 0;
        }
      };

      // --- Edit Form Event Listeners ---
      function cancelEditOrAdd() {
        const wasAdding = isAddingNewGroup;
        edit = false;
        isAddingNewGroup = false;
        newGroupDataBuffer = null;
        originalIdx = -1;
        focusOnOriginalIndexAfterUpdate = -1;
        statusEl.innerText = wasAdding ? "×”×•×¡×¤×” ×‘×•×˜×œ×”" : "×¢×¨×™×›×” ×‘×•×˜×œ×”";
        render();
        updateNav();
        updateStatusMessage();
         // Hide status message after a delay
        setTimeout(() => { if (statusEl.innerText === "×”×•×¡×¤×” ×‘×•×˜×œ×”" || statusEl.innerText === "×¢×¨×™×›×” ×‘×•×˜×œ×”") updateStatusMessage(); }, 3000);

      }
      container.addEventListener("click", (e) => {
        // Edit Button Click
        if (e.target.id === "editBtn") {
          if (!admin || edit) return;
          const idxStr = e.target.getAttribute("data-original-idx");
          const idx = parseInt(idxStr, 10);
          if (isNaN(idx)) {
            statusEl.innerText = "×©×’×™××” ×‘××™× ×“×§×¡.";
            return;
          }
          const exists = allGroups.some((g) => g.originalIndex === idx);
          if (exists) {
            originalIdx = idx;
            edit = true;
            isAddingNewGroup = false;
            render();
            updateNav();
            updateStatusMessage();
          } else {
            statusEl.innerText = "×©×’×™××”: ×œ× × ×™×ª×Ÿ ×œ××¦×•× ×§×‘×•×¦×”.";
          }
          return;
        }
        // Cancel Button Click
        if (e.target.id === "cancelBtn") {
          cancelEditOrAdd();
          return;
        }
        // Add Sentence Button Click
        if (e.target.id === "addSentence") {
          const c = document.getElementById("sentences-container");
          if (c) {
            const div = document.createElement("div");
            div.innerHTML = rowHTML("", false); // Add an empty, unlocked sentence row
            const row = div.firstElementChild;
            if (row) {
              c.appendChild(row);
              row.querySelector('input[type="text"]')?.focus(); // Focus the new input
            }
          }
          return;
        }
        // Remove Sentence Button Click
        if (e.target.classList.contains("removeSentence")) {
          const row = e.target.closest(".sentence-row");
          const c = row?.closest("#sentences-container");
          if (row && c) {
            if (c.querySelectorAll(".sentence-row").length <= 1) {
              // Prevent removing the last sentence
              statusEl.innerText = "×—×•×‘×” ×œ×”×©××™×¨ ××©×¤×˜ ××—×“.";
              row.animate(
                [
                  { backgroundColor: "rgba(255,100,100,0.3)" },
                  { backgroundColor: "transparent" },
                ],
                { duration: 600 }
              );
               setTimeout(() => { if (statusEl.innerText === "×—×•×‘×” ×œ×”×©××™×¨ ××©×¤×˜ ××—×“.") updateStatusMessage(); }, 3000);
              return;
            }
            row.remove();
          }
          return;
        }
      });

      // --- Edit Form Submit Handler ---
      container.addEventListener("submit", (e) => {
        e.preventDefault();
        if (!admin || !edit) return;
        const form = e.target;
        if (form.id !== "editForm") return;

        statusEl.innerText = "×©×•××¨...";

        const diffInput = document.getElementById("diffInput");
        const topicInput = document.getElementById("topicInput");

        const difficulty = diffInput ? parseInt(diffInput.value) || 1 : 1;
        const topic = topicInput ? topicInput.value : "×›×œ×œ×™";

        const rows = [...form.querySelectorAll(".sentence-row")];
        let errorOccurred = false;
        const sentences = rows
          .map((row) => {
            const textInput = row.querySelector(".sentence-input");
            const lockCheckbox = row.querySelector(".lock-checkbox");
            if (!textInput || !lockCheckbox) {
              if (!errorOccurred) {
                statusEl.innerText = "×©×’×™××” ×‘××‘× ×” ×”×©×•×¨×”.";
                errorOccurred = true;
              }
              return null;
            }
            const textValue = textInput.value.trim();
            if (!textValue) {
              return null; // Ignore empty sentences
            }
            return { text: textValue, movable: !lockCheckbox.checked };
          })
          .filter((s) => s !== null); // Filter out the nulls

        if (errorOccurred) return; // Stop if structure error found

        if (sentences.length === 0) {
          statusEl.innerText = "×—×•×‘×” ×œ×”×–×™×Ÿ ×œ×¤×—×•×ª ××©×¤×˜ ××—×“.";
           setTimeout(() => { if (statusEl.innerText === "×—×•×‘×” ×œ×”×–×™×Ÿ ×œ×¤×—×•×ª ××©×¤×˜ ××—×“.") updateStatusMessage(); }, 3000);
          return;
        }

        const finalGroupData = { difficulty, topic, sentences };
        const wasAdding = isAddingNewGroup;
        let savePromise;
        let savePath;
        let indexToSaveAt;

        try {
          if (wasAdding) {
            // Find the next available index
            const validIndices = allGroups
              .map((g) => g.originalIndex)
              .filter((idx) => typeof idx === "number" && !isNaN(idx));
            indexToSaveAt =
              validIndices.length > 0 ? Math.max(...validIndices) + 1 : 0;
            if (isNaN(indexToSaveAt)) {
              throw new Error("Failed to calculate next index.");
            }
            savePath = ref(db, `collections/groups/${indexToSaveAt}`);
            finalGroupData.originalIndex = indexToSaveAt; // Add originalIndex
            savePromise = set(savePath, finalGroupData);
          } else {
            // Updating existing group
            if (
              typeof originalIdx !== "number" ||
              isNaN(originalIdx) ||
              originalIdx < 0
            ) {
              throw new Error(
                `Invalid original index for update: ${originalIdx}`
              );
            }
            indexToSaveAt = originalIdx;
            savePath = ref(db, `collections/groups/${indexToSaveAt}`);
            finalGroupData.originalIndex = indexToSaveAt; // Ensure originalIndex is present
            savePromise = update(savePath, finalGroupData); // Use update for existing
          }
          console.log(`Attempting to save to index: ${indexToSaveAt}`);

          savePromise
            .then(() => {
              statusEl.innerText = wasAdding ? "×§×‘×•×¦×” ×—×“×©×” × ×©××¨×”" : "× ×©××¨";
              const savedOriginalIndex = indexToSaveAt;
              if (!wasAdding) {
                // Set focus flag only when updating, so listener restores view
                focusOnOriginalIndexAfterUpdate = savedOriginalIndex;
              }
               // Clear edit state *after* save & potentially setting flag
              cancelEditOrAdd();
              // Make sure the status message reverts after a bit
              setTimeout(() => { if (statusEl.innerText === "×§×‘×•×¦×” ×—×“×©×” × ×©××¨×”" || statusEl.innerText === "× ×©××¨") updateStatusMessage(); }, 3000);

            })
            .catch((e) => {
              console.error("Save promise error:", e);
              statusEl.innerText = "×©×’×™××” ×‘×©××™×¨×”: " + e.message;
            });
        } catch (error) {
          console.error("Error preparing save:", error);
          statusEl.innerText = "×©×’×™××” ×‘×”×›× ×” ×œ×©××™×¨×”: " + error.message;
        }
      }); // End of Submit Handler
    </script>
  </body>
</html>