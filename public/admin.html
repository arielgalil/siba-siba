<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>× ×™×”×•×œ ×©×¨×©×¨×ª ×”×¡×™×‘×•×ª â›“ï¸â€ğŸ’¥</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* ... (×›×œ ×”-CSS ×©×”×™×” ×§×•×“× × ×©××¨ ×–×”×”) ... */
      #importContainer { transition: max-height 0.5s ease-out, opacity 0.5s ease-out, padding 0.5s ease-out, border-width 0.5s ease-out; max-height: 0; opacity: 0; overflow: hidden; padding-top: 0; padding-bottom: 0; border-width: 0; }
      #importContainer.visible { max-height: 500px; opacity: 1; padding-top: 1rem; padding-bottom: 1rem; padding-left: 1rem; padding-right: 1rem; border-width: 1px; }
      textarea { color-scheme: light dark; }
      input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
      input[type="number"] { -moz-appearance: textfield; }
      button:disabled, input:disabled, select:disabled { cursor: not-allowed; opacity: 0.6; }
      select:disabled { background-color: #e5e7eb; }
      .dark select:disabled { background-color: #4b5563; }
      #importStatus.error { color: #dc2626; font-weight: bold; }
      .dark #importStatus.error { color: #f87171; }
      /* Style for pagination controls */
      .pagination-controls { display: flex; justify-content: center; align-items: center; gap: 0.5rem; margin-bottom: 1rem; margin-top: 0.5rem; }
      .pagination-controls button { padding: 0.25rem 0.75rem; }
      .pagination-controls input { width: 4rem; text-align: center; padding: 0.25rem; }
      .pagination-controls span { white-space: nowrap; }
      /* Hide elements meant only for admins */
      .admin-only-section { display: none; } /* Initially hidden */
      body.is-admin .admin-only-section { display: block; } /* Shown when admin */
      body.is-admin .non-admin-message { display: none; } /* Hide message when admin */
      body:not(.is-admin) .admin-controls { display: none; } /* Hide controls if not admin */
    </style>
  </head>
  <body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 p-6 flex flex-col items-center">
    <h1 class="text-3xl font-bold mb-4 text-center">
      × ×™×”×•×œ ×©×¨×©×¨×ª ×”×¡×™×‘×•×ª â›“ï¸â€ğŸ’¥
    </h1>
    <div id="status" class="mb-4 text-center text-sm text-gray-600 dark:text-gray-400 min-h-[1em]">×˜×•×¢×Ÿ...</div>

    <div class="mb-4 flex flex-wrap gap-2 justify-center admin-controls">
      <button id="newGroupBtn" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">â• ×”×•×¡×£ ×§×‘×•×¦×”</button>
      <button id="deleteGroupBtn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700" disabled>ğŸ—‘ï¸ ××—×§ ×§×‘×•×¦×” × ×•×›×—×™×ª</button>
      <button id="importBtn" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700">ğŸ“œ ×™×™×‘× ×§×‘×•×¦×•×ª</button>
      <button id="exportBtn" class="px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700" disabled>ğŸ“¤ ×™×¦× ×”×›×œ</button>
    </div>

    <button id="googleSignInBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 mb-4">×”×ª×—×‘×¨ ×‘×’×•×’×œ</button>

    <div id="importContainer" class="w-full max-w-xl p-4 border rounded-lg bg-gray-100 dark:bg-gray-800 mb-4 admin-controls">
        <h3 class="text-lg font-semibold mb-2">×™×™×‘×•× ×§×‘×•×¦×•×ª ××˜×§×¡×˜</h3>
        <p class="text-sm mb-2 text-gray-600 dark:text-gray-400"> ××‘× ×”: ×©×•×¨×ª × ×•×©×, ×©×•×¨×ª ×¨××ª ×§×•×©×™ (1-5), ×©×•×¨×•×ª ××©×¤×˜×™× (×¢× '*' ×œ× ×¢×•×œ), ×©×•×¨×” ×¨×™×§×” ×‘×™×Ÿ ×§×‘×•×¦×•×ª. </p>
        <textarea id="importText" rows="10" class="w-full p-2 border rounded bg-white dark:bg-gray-700 mb-2" placeholder="× ×•×©× ×”×§×‘×•×¦×” ×”×¨××©×•× ×”..."></textarea>
        <button id="submitImportBtn" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">×‘×¦×¢ ×™×™×‘×•×</button>
        <div id="importStatus" class="mt-2 text-sm text-gray-600 dark:text-gray-400"></div>
    </div>

    <div class="w-full max-w-xl admin-only-section">
        <div class="mb-4">
            <input type="search" id="searchInput" placeholder="×—×™×¤×•×©..." class="w-full p-2 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100" disabled />
        </div>
        <div class="mb-4 flex flex-wrap gap-4 justify-center items-center">
            <label class="block whitespace-nowrap"> ×¡×™× ×•×Ÿ × ×•×©×: <select id="topicFilter" class="p-1 border rounded bg-white dark:bg-gray-700" disabled> <option value="all">×”×›×œ</option> </select> </label>
            <label class="block whitespace-nowrap"> ×¡×™× ×•×Ÿ ×¨××”: <select id="difficultyFilter" class="p-1 border rounded bg-white dark:bg-gray-700" disabled> <option value="all">×”×›×œ</option> <option value="1">1</option> <option value="2">2</option> <option value="3">3</option> <option value="4">4</option> <option value="5">5</option> </select> </label>
            <button id="clearFiltersBtn" class="px-3 py-1 bg-gray-400 text-black rounded hover:bg-gray-500" disabled> × ×§×” ×¡×™× ×•× ×™× </button>
        </div>
        <div class="pagination-controls top-pagination">
            <button class="prevBtn px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg" disabled>×”×§×•×“×</button>
            <span>×¢××•×“</span>
            <input class="pageInput w-16 px-2 py-1 border rounded-lg text-center bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100" type="number" min="1" value="1" disabled />
            <span class="pageCount">/ 1</span>
            <button class="nextBtn px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg" disabled>×”×‘×</button>
        </div>
    </div>

    <div id="group-container" class="w-full max-w-xl min-h-[200px]">
        <p class="text-center text-gray-500 dark:text-gray-400 non-admin-message">
            ×× × ×”×ª×—×‘×¨ ×¢× ×—×©×‘×•×Ÿ ×’×•×’×œ ×‘×¢×œ ×”×¨×©××•×ª × ×™×”×•×œ ×›×“×™ ×œ×¦×¤×•×ª ×•×œ× ×”×œ ×ª×¨×’×™×œ×™×.
        </p>
        <p class="text-center text-gray-500 dark:text-gray-400 admin-only-section">
            ×˜×•×¢×Ÿ × ×ª×•× ×™×...
        </p>
    </div>

    <div class="w-full max-w-xl admin-only-section">
        <div class="pagination-controls bottom-pagination">
            <button class="prevBtn px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg" disabled>×”×§×•×“×</button>
            <span>×¢××•×“</span>
            <input class="pageInput w-16 px-2 py-1 border rounded-lg text-center bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100" type="number" min="1" value="1" disabled />
            <span class="pageCount">/ 1</span>
            <button class="nextBtn px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg" disabled>×”×‘×</button>
        </div>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
      import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-auth.js";
      import { getDatabase, ref, onValue, update, set, remove, get } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-database.js";

      // --- Firebase Configuration (trivbio) ---
      const firebaseConfig = { /* ... ×”×’×“×¨×•×ª ×”×¤×¨×•×™×§×˜ trivbio ... */
        apiKey: "AIzaSyAGFC_TB8iEMvS2PyxeASj1HH4i66AW4UA", authDomain: "trivbio.firebaseapp.com", databaseURL: "https://trivbio-default-rtdb.firebaseio.com", projectId: "trivbio", storageBucket: "trivbio.appspot.com", messagingSenderId: "1097087574583", appId: "1:1097087574583:web:b36c0441537a1f596215b2", measurementId: "G-ZY245YB23E",
       };
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getDatabase(app);
      const groupsRef = ref(db, "collections/groups");

      // --- DOM Element References ---
      const statusEl = document.getElementById("status");
      const googleBtn = document.getElementById("googleSignInBtn");
      const adminControlElements = document.querySelectorAll('.admin-controls'); // Select all admin control sections
      const adminOnlySections = document.querySelectorAll('.admin-only-section'); // Select all admin view sections
      const container = document.getElementById("group-container");
      // Pagination Controls (Query all matching elements)
      const paginationContainers = document.querySelectorAll('.pagination-controls');
      const prevBtns = document.querySelectorAll(".prevBtn");
      const nextBtns = document.querySelectorAll(".nextBtn");
      const pageInputs = document.querySelectorAll(".pageInput");
      const pageCounts = document.querySelectorAll(".pageCount");
      // Other Controls
      const searchInput = document.getElementById("searchInput");
      const topicFilter = document.getElementById("topicFilter");
      const difficultyFilter = document.getElementById("difficultyFilter");
      const clearFiltersBtn = document.getElementById("clearFiltersBtn");
      const newBtn = document.getElementById("newGroupBtn");
      const delBtn = document.getElementById("deleteGroupBtn");
      const importBtn = document.getElementById("importBtn");
      const exportBtn = document.getElementById("exportBtn");
      const importContainer = document.getElementById("importContainer");
      const importText = document.getElementById("importText");
      const submitImportBtn = document.getElementById("submitImportBtn");
      const importStatusEl = document.getElementById("importStatus");


      // --- Global State Variables ---
      const TOPICS = ["×›×œ×œ×™", "×”×ª×", "×’×•×£ ×”××“×", "××§×•×œ×•×’×™×”", "××¢×‘×“×”"];
      const ITEMS_PER_PAGE = 3; // Number of groups per page
      let allGroups = [];
      let filteredGroups = [];
      let originalIdx = -1; // Index for editing (still needed for identifying which item is being edited)
      // let filteredIdx = 0; // No longer needed, using currentPage
      let currentPage = 1; // Current page number
      let totalPages = 1; // Total number of pages
      let admin = false;
      let edit = false;
      let isAddingNewGroup = false;
      let newGroupDataBuffer = null;
      let currentAuthUser = null;
      let currentSearchTerm = "";
      let currentTopicFilter = "all";
      let currentDifficultyFilter = "all";
      // let focusOnOriginalIndexAfterUpdate = -1; // Less relevant with pagination, can be removed or adapted

      // --- Initialization ---
      const topicOptionsHTML = TOPICS.map(t => `<option value="${t}">${t}</option>`).join("");
      topicFilter.innerHTML += topicOptionsHTML;

      // --- Authentication Setup ---
      function initializeAuthListener() {
        onAuthStateChanged(auth, (u) => {
          currentAuthUser = u;
          if (u) {
            const isGoogleSignIn = u.providerData.some(p => p.providerId === "google.com");
             if (isGoogleSignIn) {
              googleBtn.style.display = 'none'; // Hide login button
              statusEl.innerText = `××—×•×‘×¨: ${u.email}`; checkAdminStatus(u.uid);
            } else {
              googleBtn.style.display = 'block'; statusEl.innerText = "××—×•×‘×¨ ×× ×•× ×™××™×ª. ×”×ª×—×‘×¨ ×¢× ×’×•×’×œ ×œ× ×™×”×•×œ."; admin = false; updateAdminUI(); listenForGroups(); // Listen even if anon, but UI will restrict
            }
          } else {
            googleBtn.style.display = 'block'; statusEl.innerText = "××™× ×š ××—×•×‘×¨. ×”×ª×—×‘×¨ ×¢× ×’×•×’×œ ×œ× ×™×”×•×œ."; admin = false; updateAdminUI(); allGroups = []; edit = false; isAddingNewGroup = false; applyFiltersAndSearch(); // Render empty state
          }
        });
      }

      setPersistence(auth, browserLocalPersistence)
        .then(() => { console.log("Firebase Auth persistence set to local."); initializeAuthListener(); })
        .catch((error) => { console.error("Error setting Firebase Auth persistence:", error); statusEl.innerText = "×©×’×™××” ×‘×”×’×“×¨×ª ×©××™×¨×ª ×”×ª×—×‘×¨×•×ª."; initializeAuthListener(); });

      const provider = new GoogleAuthProvider();
      googleBtn.onclick = () => signInWithPopup(auth, provider).catch(e => (statusEl.innerText = "×©×’×™××ª ×”×ª×—×‘×¨×•×ª ×’×•×’×œ: " + e.message));

      function checkAdminStatus(uid) {
        const adminRef = ref(db, `admins/${uid}`);
        get(adminRef)
          .then((snapshot) => {
            admin = snapshot.exists() && snapshot.val() === true;
            updateAdminUI(); if (!admin && statusEl.innerText.startsWith("××—×•×‘×¨:")) { statusEl.innerText += " (×œ× ×× ×”×œ)"; }
            listenForGroups(); // Always listen, UI/render function handles visibility
          })
          .catch((error) => { console.error("Error checking admin status:", error); admin = false; updateAdminUI(); listenForGroups(); });
      }

      // --- UI Update Function ---
      function updateAdminUI() {
          // Add/remove 'is-admin' class from body for CSS targeting
          document.body.classList.toggle('is-admin', admin);

          // Hide import container if not admin and it's visible
          if (!admin) { importContainer.classList.remove("visible"); }
          // Cancel edit mode if user loses admin status
          if (!admin && edit) { cancelEditOrAdd(); }

          // Enable/disable filters only if admin
          const disableFiltersAndNav = !admin || edit;
          searchInput.disabled = disableFiltersAndNav;
          topicFilter.disabled = disableFiltersAndNav;
          difficultyFilter.disabled = disableFiltersAndNav;
          clearFiltersBtn.disabled = disableFiltersAndNav;
          // Enable/disable pagination controls if admin and not editing
          paginationContainers.forEach(pc => pc.style.display = (admin && !edit) ? 'flex' : 'none');

          render(); // Re-render based on new admin status
          updateNav(); // Update nav states based on new admin status and data
      }


      // --- Data Handling ---
      function listenForGroups() {
        // No early exit for admin, fetch data but render conditionally
        onValue(groupsRef, (snap) => {
            const groupsData = snap.val(); let processedGroups = [];
            if (groupsData) { /* ... processing logic as before ... */
              if (Array.isArray(groupsData)) { processedGroups = groupsData.map((group, index) => group ? { ...group, originalIndex: index } : null).filter(Boolean); }
              else if (typeof groupsData === 'object') { processedGroups = Object.entries(groupsData).map(([key, group]) => { const index = parseInt(key, 10); return (group && !isNaN(index)) ? { ...group, originalIndex: index } : null; }).filter(Boolean).sort((a, b) => a.originalIndex - b.originalIndex); }
            }
            allGroups = processedGroups;
            if ((edit || isAddingNewGroup) && allGroups.length === 0) cancelEditOrAdd();
            applyFiltersAndSearch(); // Apply filters and *sorting*

             // Reset to page 1 after data update/filtering unless editing
             if(!edit) {
                currentPage = 1;
             }

             updateStatusMessage(); render(); updateNav();
          },
          (error) => { /* ... error handling ... */
              console.error("Error fetching groups:", error); statusEl.innerText = "×©×’×™××” ×‘×§×¨×™××ª × ×ª×•× ×™×."; allGroups = []; edit = false; isAddingNewGroup = false; applyFiltersAndSearch(); updateStatusMessage(); render(); updateNav();
           }
        );
      }

      function updateStatusMessage() { /* ... status logic ... */
          if (!admin) return; // Don't show detailed status if not admin
          if (edit) { statusEl.innerText = isAddingNewGroup ? "××™×œ×•×™ ×¤×¨×˜×™ ×§×‘×•×¦×” ×—×“×©×”..." : `×¢×¨×™×›×ª ×§×‘×•×¦×” ${originalIdx}...`; return; }
          if (allGroups.length === 0) { statusEl.innerText = "××™×Ÿ ×§×‘×•×¦×•×ª. ×”×•×¡×£ ××• ×™×™×‘×."; }
          else if (filteredGroups.length === 0) { statusEl.innerText = `×œ× × ××¦××• ×§×‘×•×¦×•×ª ×‘×¡×™× ×•×Ÿ ××ª×•×š ${allGroups.length}.`; }
          else {
              const startItem = Math.min(((currentPage - 1) * ITEMS_PER_PAGE) + 1, filteredGroups.length);
              const endItem = Math.min(currentPage * ITEMS_PER_PAGE, filteredGroups.length);
              statusEl.innerText = `××¦×™×’ ${startItem}-${endItem} ××ª×•×š ${filteredGroups.length} (×¡×”"×› ${allGroups.length})`;
          }
      }

      // --- Filtering and Sorting ---
      function applyFiltersAndSearch() {
        // Filtering logic (as before)
        const searchTerm = currentSearchTerm.toLowerCase();
        filteredGroups = allGroups.filter((group) => {
          if (!group || !group.sentences || !Array.isArray(group.sentences) || typeof group.originalIndex !== "number") return false;
          const diffMatch = currentDifficultyFilter === "all" || group.difficulty == currentDifficultyFilter;
          const topicMatch = currentTopicFilter === "all" || (group.topic || "×›×œ×œ×™") === currentTopicFilter;
          const searchMatch = searchTerm === "" || (group.topic || "").toLowerCase().includes(searchTerm) || group.sentences.some(s => s && s.text && s.text.toLowerCase().includes(searchTerm));
          return diffMatch && topicMatch && searchMatch;
        });

        // *** ADDED: Client-side sorting by difficulty ***
        filteredGroups.sort((a, b) => (a.difficulty || 0) - (b.difficulty || 0));

        // Reset to page 1 whenever filters/search changes
        currentPage = 1;
       }

      // --- Event Listeners for Search/Filter ---
      searchInput.addEventListener("input", () => { if (edit) return; currentSearchTerm = searchInput.value; applyFiltersAndSearch(); render(); updateNav(); updateStatusMessage(); });
      topicFilter.addEventListener("change", () => { if (edit) return; currentTopicFilter = topicFilter.value; applyFiltersAndSearch(); render(); updateNav(); updateStatusMessage(); });
      difficultyFilter.addEventListener("change", () => { if (edit) return; currentDifficultyFilter = difficultyFilter.value; applyFiltersAndSearch(); render(); updateNav(); updateStatusMessage(); });
      clearFiltersBtn.addEventListener("click", () => { if (edit) return; searchInput.value = ""; topicFilter.value = "all"; difficultyFilter.value = "all"; currentSearchTerm = ""; currentTopicFilter = "all"; currentDifficultyFilter = "all"; applyFiltersAndSearch(); render(); updateNav(); updateStatusMessage(); });

      // --- Group Actions ---
      newBtn.onclick = () => { /* ... new group logic - ensure sentences[0] has ID ... */
          if (!admin || edit) return; edit = true; isAddingNewGroup = true;
          newGroupDataBuffer = { difficulty: 1, topic: "×›×œ×œ×™", sentences: [{ text: "", movable: true, id: `s_${Date.now()}_0` }] }; // Added initial ID
          originalIdx = -1; render(); updateNav(); updateStatusMessage();
       };
      delBtn.onclick = () => { /* ... delete logic - needs adjustment for pagination */
          if (!admin || edit || filteredGroups.length === 0) return;
          // Find the actual item index based on currentPage and relative index if needed,
          // but deleting by originalIndex is safer if available. Let's assume deletion
          // happens from the view mode where originalIdx is known.
          // We need the originalIndex of the currently viewed/selected item for deletion.
          // This needs rethinking if deleting directly from the paginated list without an explicit selection.
          // For now, assume 'originalIdx' holds the index of the group being VIEWED before delete was clicked.
          // Or, maybe disable delete button if multiple items are shown? Or add delete buttons per item?
          // Let's disable delete for now in pagination view, enable only when editing?
          alert("Delete functionality needs review for paginated view. Currently disabled in this mode.");
          // Original delete logic commented out:
          // const groupToDelete = ... ; // Need a way to identify which group to delete from the list
          // const idxToDelete = groupToDelete.originalIndex;
          // ... confirm ... remove ...
       };

      // --- Import/Export Logic --- (Needs no significant changes for pagination)
      importBtn.onclick = () => { /* ... */ if (!admin || edit) return; importContainer.classList.toggle("visible"); importStatusEl.innerText = ""; importStatusEl.classList.remove("error"); importText.value = ""; if (importContainer.classList.contains("visible") && edit) cancelEditOrAdd(); };
      exportBtn.onclick = () => { /* ... */ if (!admin || edit || allGroups.length === 0) return; exportGroups(allGroups); };
      submitImportBtn.onclick = () => { /* ... */ if (!admin) return; const text = importText.value.trim(); importStatusEl.classList.remove("error"); if (!text) { importStatusEl.innerText = "×ª×™×‘×ª ×˜×§×¡×˜ ×¨×™×§×”."; return; } importStatusEl.innerText = "××¢×‘×“..."; const parsed = parseImportText(text); if (parsed.error) { importStatusEl.innerText = `×©×’×™××ª × ×™×ª×•×—: ${parsed.error}`; importStatusEl.classList.add("error"); return; } if (parsed.groups.length === 0) { importStatusEl.innerText = "×œ× × ××¦××• ×§×‘×•×¦×•×ª ×ª×§×™× ×•×ª ×œ×™×™×‘×•×."; return; } importGroupsToFirebase(parsed.groups); };
      function parseImportText(text) { /* ... Needs to generate sentence IDs ... */
        const blocks = text.split(/\n\s*\n/); const newGroups = []; let error = null;
        blocks.forEach((block, blockIndex) => {
          if (error) return; const lines = block.trim().split("\n").map(l => l.trim()); const nonEmptyLines = lines.filter(l => l);
          if (nonEmptyLines.length < 3) { if (nonEmptyLines.length > 0) { error = `×‘×œ×•×§ ${blockIndex + 1}: ×œ× ×ª×§×™×Ÿ (× ×•×©×, ×¨××”, ××©×¤×˜).`; } return; }
          const topicLine = nonEmptyLines[0]; const topic = TOPICS.includes(topicLine) ? topicLine : "×›×œ×œ×™";
          const difficultyLine = nonEmptyLines[1]; const parsedDifficulty = parseInt(difficultyLine, 10); let difficulty;
          if (isNaN(parsedDifficulty) || parsedDifficulty < 1 || parsedDifficulty > 5) { error = `×‘×œ×•×§ ${blockIndex + 1}: ×¨××” (${difficultyLine}) ×©×’×•×™×”.`; return; } else { difficulty = parsedDifficulty; }
          const sentences = nonEmptyLines.slice(2).map((line, index) => { const isLocked = line.startsWith("*"); const text = isLocked ? line.substring(1).trim() : line.trim(); if (!text) return null; const sentenceId = `s_import_${Date.now()}_${blockIndex}_${index}`; return { text: text, movable: !isLocked, id: sentenceId }; }).filter(s => s !== null);
          if (sentences.length === 0) { error = `×‘×œ×•×§ ${blockIndex + 1}: ×œ× × ××¦××• ××©×¤×˜×™× ×ª×§×™× ×™×.`; return; }
          newGroups.push({ difficulty: difficulty, topic: topic, sentences: sentences });
        }); return { groups: newGroups, error: error };
      }
      async function importGroupsToFirebase(parsedGroups) { /* ... */ if (!admin) return; importStatusEl.innerText = `××™×™×‘× ${parsedGroups.length}...`; try { const validIndices = allGroups.map(g => g.originalIndex).filter(idx => typeof idx === "number" && !isNaN(idx)); let nextIdx = validIndices.length > 0 ? Math.max(...validIndices) + 1 : 0; if (isNaN(nextIdx)) throw new Error("Could not determine next index."); const updates = {}; parsedGroups.forEach((group) => { const newIdx = nextIdx++; updates[newIdx] = { ...group, originalIndex: newIdx }; }); if (Object.keys(updates).length > 0) { await update(ref(db, "collections/groups"), updates); importStatusEl.innerText = `×™×™×‘×•× ×”×•×©×œ×! × ×•×¡×¤×• ${parsedGroups.length} ×§×‘×•×¦×•×ª.`; importStatusEl.classList.remove("error"); importText.value = ""; importContainer.classList.remove("visible"); } else { importStatusEl.innerText = "×œ× × ××¦××• ×§×‘×•×¦×•×ª ×œ×™×™×‘×."; importStatusEl.classList.remove("error"); } } catch (e) { console.error("Import error:", e); importStatusEl.innerText = "×©×’×™××” ×‘×™×™×‘×•×: " + e.message; importStatusEl.classList.add("error"); } }
      function exportGroups(groupsToExport) { /* ... */ if (!groupsToExport || groupsToExport.length === 0) { statusEl.innerText = "××™×Ÿ ×§×‘×•×¦×•×ª ×œ×™×™×¦×."; return; } let exportText = ""; groupsToExport.forEach((group, index) => { if (!group || !group.sentences || !Array.isArray(group.sentences)) { console.warn("Skipping invalid group during export:", group); return; } exportText += group.topic || "×›×œ×œ×™"; exportText += "\n"; exportText += group.difficulty || 1; exportText += "\n"; group.sentences.forEach(sentence => { if (sentence && sentence.text) { exportText += (sentence.movable === false ? "*" : "") + sentence.text; exportText += "\n"; } }); if (index < groupsToExport.length - 1) exportText += "\n"; }); const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' }); const link = document.createElement("a"); const url = URL.createObjectURL(blob); link.setAttribute("href", url); link.setAttribute("download", "exported_question_groups.txt"); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); statusEl.innerText = "×”×§×‘×•×¦×•×ª ×™×•×¦××• ×œ×§×•×‘×¥."; setTimeout(() => { if (statusEl.innerText === "×”×§×‘×•×¦×•×ª ×™×•×¦××• ×œ×§×•×‘×¥.") updateStatusMessage(); }, 3000); }

      // --- Rendering Logic ---
      const rowHTML = (text, locked, sentenceId) => ` <div class="sentence-row flex items-center space-x-2 space-x-reverse mb-2" data-sentence-id="${sentenceId || ''}"><input type="text" value="${text || ""}" class="sentence-input flex-1 p-2 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100" placeholder="×”×–×Ÿ ××©×¤×˜ ×›××Ÿ" /><label class="inline-flex items-center space-x-1 space-x-reverse" title="× ×¢×œ ××©×¤×˜"><input type="checkbox" ${locked ? "checked" : ""} class="lock-checkbox h-5 w-5 accent-blue-500" /><span>ğŸ”’</span></label><button type="button" class="removeSentence text-red-500 hover:text-red-700 font-bold text-lg" title="××—×§ ××©×¤×˜">âœ–ï¸</button></div>`;

      // Updated view function for single group (used within render loop)
      function renderSingleGroupView(g) {
          if (!g || typeof g.originalIndex !== "number") return '<article class="text-red-500 dark:text-red-400 p-4 border rounded mb-4">×©×’×™××” ×‘× ×ª×•× ×™ ×§×‘×•×¦×”.</article>';
          const topic = g.topic || "×›×œ×œ×™"; const diff = g.difficulty || "?"; const title = `${topic} - ×¨××” ${diff}`;
          // Add edit button per group
          const editBtnHTML = `<button data-original-idx="${g.originalIndex}" class="editBtn inline-block ml-4 text-blue-500 hover:text-blue-700 text-sm" title="×¢×¨×•×š ×§×‘×•×¦×” ×–×•">[×¢×¨×•×š]</button>`;
          return `<article class="border rounded-lg shadow p-4 bg-gray-50 dark:bg-gray-800 mb-4">
                      <header class="mb-2 flex justify-between items-center">
                          <h2 class="text-lg font-semibold">${title} (ID: ${g.originalIndex})</h2>
                          ${editBtnHTML}
                      </header>
                      <h3 class="text-md font-semibold mb-1">××©×¤×˜×™×:</h3>
                      <ol class="list-decimal list-outside mr-5 space-y-1 text-sm">
                          ${g.sentences && Array.isArray(g.sentences) && g.sentences.length > 0 ? g.sentences.map(s => `<li>${s.text || "(×¨×™×§)"}${!s.movable ? ' <span class="text-xs text-green-600 dark:text-green-400" title="× ×¢×•×œ">ğŸ”’</span>' : ""}</li>`).join("") : "<li>××™×Ÿ ××©×¤×˜×™×.</li>"}
                      </ol>
                  </article>`;
      }

      function editForm(g) { /* ... edit form rendering logic (as before) ... */
          const data = isAddingNewGroup ? newGroupDataBuffer : g; if (!data) return '<p>×©×’×™××” ×‘×˜×•×¤×¡.</p>';
          const rows = (data.sentences || []).map(s => rowHTML(s.text || "", !s.movable, s.id)).join("");
          const topic = data.topic || "×›×œ×œ×™"; const title = isAddingNewGroup ? "×”×•×¡×¤×ª ×§×‘×•×¦×” ×—×“×©×”" : `×¢×¨×™×›×ª ×§×‘×•×¦×” (ID: ${originalIdx})`;
          return `<div class="border rounded-2xl shadow-lg p-4 bg-gray-50 dark:bg-gray-800"><h2 class="text-2xl font-semibold mb-2">${title}</h2><form id="editForm" class="space-y-3"><div class="flex flex-wrap gap-4 items-center mb-4"><label class="block">×¨××ª ×§×•×©×™: <input id="diffInput" type="number" value="${data.difficulty || 1}" min="1" max="5" class="p-1 border rounded bg-white dark:bg-gray-700 w-16 text-gray-900 dark:text-gray-100" /></label><label class="block">× ×•×©×: <select id="topicInput" class="p-1 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">${TOPICS.map( t => `<option value="${t}" ${t === topic ? "selected" : ""}>${t}</option>`).join("")}</select></label></div><div id="sentences-container"><h3 class="text-lg font-semibold mb-2">××©×¤×˜×™×:</h3>${rows}</div><button type="button" id="addSentence" class="mt-2 px-3 py-1 bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 rounded text-gray-900 dark:text-gray-100">â• ×”×•×¡×£ ××©×¤×˜</button><div class="flex justify-between mt-4"><button type="button" id="cancelBtn" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">×‘×™×˜×•×œ</button><button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">×©××•×¨ ×•×¡×’×•×¨</button></div></form></div>`;
       }

      // --- Updated Render Function ---
      function render() {
          if (!admin) {
              // Show only the non-admin message if not admin
              container.innerHTML = `<p class="text-center text-gray-500 dark:text-gray-400 non-admin-message">
                                        ×× × ×”×ª×—×‘×¨ ×¢× ×—×©×‘×•×Ÿ ×’×•×’×œ ×‘×¢×œ ×”×¨×©××•×ª × ×™×”×•×œ ×›×“×™ ×œ×¦×¤×•×ª ×•×œ× ×”×œ ×ª×¨×’×™×œ×™×.
                                     </p>`;
              return;
          }

          // If admin, proceed with rendering logic
          if (edit) {
              // Find the specific group being edited (or use buffer for new)
              const groupToEdit = isAddingNewGroup ? null : allGroups.find(g => g.originalIndex === originalIdx);
              container.innerHTML = editForm(groupToEdit);
          } else {
              // Paginated view
              if (filteredGroups.length > 0) {
                  const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
                  const endIndex = startIndex + ITEMS_PER_PAGE;
                  const groupsToDisplay = filteredGroups.slice(startIndex, endIndex);
                  // Render the list of groups for the current page
                  container.innerHTML = groupsToDisplay.map(renderSingleGroupView).join('');
              } else {
                  // Show no groups message
                  const hasFilters = currentSearchTerm || currentTopicFilter !== "all" || currentDifficultyFilter !== "all";
                  container.innerHTML = allGroups.length === 0 ? '<p class="text-gray-500 dark:text-gray-400">××™×Ÿ ×§×‘×•×¦×•×ª. ×”×•×¡×£ ××• ×™×™×‘×.</p>' : hasFilters ? '<p class="text-gray-500 dark:text-gray-400">×œ× × ××¦××• ×§×‘×•×¦×•×ª ×‘×¡×™× ×•×Ÿ ×–×”.</p>' : '<p class="text-gray-500 dark:text-gray-400">×˜×•×¢×Ÿ...</p>';
              }
          }
      }

      // --- Updated Navigation Logic ---
      function updateNav() {
          if (!admin) { // Hide pagination if not admin
             paginationContainers.forEach(pc => pc.style.display = 'none');
             return;
          }
          // Show pagination only if admin and not editing
          paginationContainers.forEach(pc => pc.style.display = edit ? 'none' : 'flex');

          totalPages = Math.ceil(filteredGroups.length / ITEMS_PER_PAGE);
          if (totalPages === 0) totalPages = 1; // Prevent division by zero issues, show page 1/1

          // Update both sets of controls
          pageInputs.forEach(input => {
              input.disabled = edit || filteredGroups.length <= ITEMS_PER_PAGE;
              input.value = currentPage;
              input.max = totalPages;
              input.min = 1;
          });
          pageCounts.forEach(span => span.innerText = `/ ${totalPages}`);
          prevBtns.forEach(btn => btn.disabled = edit || currentPage <= 1);
          nextBtns.forEach(btn => btn.disabled = edit || currentPage >= totalPages);

          // Update admin action buttons based on edit state and admin status
          const disableAdminActions = !admin || edit;
          newBtn.disabled = disableAdminActions;
          importBtn.disabled = disableAdminActions;
          exportBtn.disabled = disableAdminActions || allGroups.length === 0;
          // Disable delete button in paginated view (for now) or if editing
          delBtn.disabled = true; // Simplification: Disable delete unless specifically enabled later
      }

      // Event Listeners for Pagination (handle both sets)
      function goToPage(newPage) {
          if (edit) return;
          const newPageNum = Math.max(1, Math.min(newPage, totalPages)); // Clamp page number
          if (newPageNum !== currentPage) {
              currentPage = newPageNum;
              render();
              updateNav();
              updateStatusMessage();
          }
      }

      prevBtns.forEach(btn => btn.onclick = () => goToPage(currentPage - 1));
      nextBtns.forEach(btn => btn.onclick = () => goToPage(currentPage + 1));
      pageInputs.forEach(input => input.onchange = (e) => {
          if (edit) return;
          let targetPage = parseInt(e.target.value, 10);
          if (isNaN(targetPage)) targetPage = 1; // Default to 1 if invalid input
          goToPage(targetPage);
      });


      function cancelEditOrAdd() { /* ... cancel logic ... */
          edit = false; isAddingNewGroup = false; newGroupDataBuffer = null; originalIdx = -1;
          statusEl.innerText = "×‘×•×˜×œ";
          document.body.classList.remove('editing'); // Optional class to indicate edit mode
          updateAdminUI(); // This calls render() and updateNav()
          updateStatusMessage();
          setTimeout(() => { if (statusEl.innerText === "×‘×•×˜×œ") updateStatusMessage(); }, 3000);
       }

      // Updated Container Click Handler (Handles Edit button within rendered list)
      container.addEventListener("click", (e) => {
           // Edit Button Click (now attached to each rendered group)
           if (e.target.classList.contains("editBtn") || e.target.closest('.editBtn')) {
               const button = e.target.closest('.editBtn');
               if (!admin || edit || !button) return;
               const idxStr = button.getAttribute("data-original-idx");
               const idx = parseInt(idxStr, 10);
               if (isNaN(idx)) { statusEl.innerText = "×©×’×™××ª ××™× ×“×§×¡."; return; }
               const exists = allGroups.some(g => g.originalIndex === idx);
               if (exists) {
                   originalIdx = idx; edit = true; isAddingNewGroup = false;
                   document.body.classList.add('editing'); // Add editing class for potential styling
                   updateAdminUI(); // This calls render() and updateNav()
                   updateStatusMessage();
               } else { statusEl.innerText = "×©×’×™××”: ×§×‘×•×¦×” ×œ× × ××¦××”."; }
               return;
           }

           // Handle clicks within the edit form (Cancel, Add/Remove Sentence)
           if (edit) {
                if (e.target.id === "cancelBtn") { cancelEditOrAdd(); return; }
                if (e.target.id === "addSentence") { /* ... add sentence logic ... */ const c = document.getElementById("sentences-container"); if (c) { const div = document.createElement("div"); const newSentenceId = `s_${Date.now()}_new`; div.innerHTML = rowHTML("", false, newSentenceId); const row = div.firstElementChild; if (row) { c.appendChild(row); row.querySelector('input[type="text"]')?.focus(); } } return; }
                if (e.target.classList.contains("removeSentence")) { /* ... remove sentence logic ... */ const row = e.target.closest(".sentence-row"); const c = row?.closest("#sentences-container"); if (row && c) { if (c.querySelectorAll(".sentence-row").length <= 1) { statusEl.innerText = "×—×•×‘×” ×œ×”×©××™×¨ ××©×¤×˜ ××—×“."; row.animate([{ backgroundColor: "rgba(255,100,100,0.3)" }, { backgroundColor: "transparent" }], { duration: 600 }); setTimeout(() => updateStatusMessage(), 3000); return; } row.remove(); } return; }
           }
       });

      // --- Edit Form Submit Handler (Corrected - Adds sentence IDs) ---
      container.addEventListener("submit", (e) => {
        e.preventDefault(); if (!admin || !edit) return; const form = e.target; if (form.id !== "editForm") return;
        statusEl.innerText = "×©×•××¨...";
        const diffInput = document.getElementById("diffInput"); const topicInput = document.getElementById("topicInput");
        const difficulty = diffInput ? parseInt(diffInput.value) || 1 : 1; const topic = topicInput ? topicInput.value : "×›×œ×œ×™";
        const rows = [...form.querySelectorAll(".sentence-row")]; let errorOccurred = false;

        const sentences = rows.map((row, index) => {
            const textInput = row.querySelector(".sentence-input");
            const lockCheckbox = row.querySelector(".lock-checkbox");
            let sentenceId = row.getAttribute('data-sentence-id'); // Get existing ID from attribute
            if (!sentenceId) { sentenceId = `s_${Date.now()}_${index}`; console.log("Generated missing ID for sentence:", sentenceId); } // Generate if missing
            if (!textInput || !lockCheckbox) { console.error("Structure error in row:", row); errorOccurred = true; return null; }
            const textValue = textInput.value.trim();
            if (!textValue) return null;
            return { text: textValue, movable: !lockCheckbox.checked, id: sentenceId };
          }).filter(s => s !== null);

        if (errorOccurred) { statusEl.innerText = "×©×’×™××” ×‘××‘× ×” ××—×“ ×”××©×¤×˜×™×."; return; }
        if (sentences.length === 0) { statusEl.innerText = "×—×•×‘×” ×œ×”×–×™×Ÿ ×œ×¤×—×•×ª ××©×¤×˜ ××—×“."; setTimeout(() => updateStatusMessage(), 3000); return; }

        const finalGroupDataBase = { difficulty, topic, sentences }; let finalGroupData = {};
        const wasAdding = isAddingNewGroup; let savePromise; let savePath; let indexToSaveAt;
        try {
          if (wasAdding) { const validIndices = allGroups.map(g => g.originalIndex).filter(idx => typeof idx === "number" && !isNaN(idx)); indexToSaveAt = validIndices.length > 0 ? Math.max(...validIndices) + 1 : 0; if (isNaN(indexToSaveAt)) throw new Error("Idx calc failed."); savePath = ref(db, `collections/groups/${indexToSaveAt}`); finalGroupData = { ...finalGroupDataBase, originalIndex: indexToSaveAt }; savePromise = set(savePath, finalGroupData); }
          else { if (typeof originalIdx !== "number" || isNaN(originalIdx) || originalIdx < 0) throw new Error(`Invalid original index: ${originalIdx}`); indexToSaveAt = originalIdx; savePath = ref(db, `collections/groups/${indexToSaveAt}`); finalGroupData = { ...finalGroupDataBase, originalIndex: indexToSaveAt }; savePromise = update(savePath, finalGroupData); }
          console.log(`Saving to index: ${indexToSaveAt}`, finalGroupData);
          savePromise.then(() => { statusEl.innerText = wasAdding ? "×§×‘×•×¦×” ×—×“×©×” × ×©××¨×”" : "× ×©××¨"; const savedOriginalIndex = indexToSaveAt; /* focusOnOriginalIndexAfterUpdate = savedOriginalIndex; */ cancelEditOrAdd(); setTimeout(() => updateStatusMessage(), 3000); }).catch((e) => { console.error("Save promise error:", e); statusEl.innerText = "×©×’×™××” ×‘×©××™×¨×”: " + e.message; });
        } catch (error) { console.error("Error preparing save:", error); statusEl.innerText = "×©×’×™××” ×‘×”×›× ×” ×œ×©××™×¨×”: " + error.message; }
      }); // End of Submit Handler

      // Initial Load Trigger
      initializeAuthListener(); // Start the auth process

    </script>
  </body>
</html>
