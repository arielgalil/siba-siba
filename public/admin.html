<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>× ×™×”×•×œ ×©×¨×©×¨×ª ×”×¡×™×‘×•×ª â›“ï¸â€ğŸ’¥</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Style for the import container */
      #importContainer {
        transition: max-height 0.5s ease-out, opacity 0.5s ease-out,
          padding 0.5s ease-out, border-width 0.5s ease-out;
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        padding-top: 0;
        padding-bottom: 0;
        border-width: 0;
      }
      #importContainer.visible {
        max-height: 500px; /* Adjust as needed */
        opacity: 1;
        padding-top: 1rem;
        padding-bottom: 1rem;
        padding-left: 1rem;
        padding-right: 1rem;
        border-width: 1px;
      }
      /* Ensure textarea respects dark mode */
      textarea {
        color-scheme: light dark;
      }
      /* Prevent number input spinner */
       input[type=number]::-webkit-inner-spin-button,
       input[type=number]::-webkit-outer-spin-button {
           -webkit-appearance: none;
           margin: 0;
       }
       input[type=number] {
           -moz-appearance: textfield; /* Firefox */
       }
       /* Style disabled elements more clearly */
        button:disabled, input:disabled, select:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        select:disabled {
             background-color: #e5e7eb; /* Tailwind gray-200 */
        }
        .dark select:disabled {
             background-color: #4b5563; /* Tailwind gray-600 */
        }

    </style>
  </head>
  <body
    class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 p-6 flex flex-col items-center"
  >
    <h1 class="text-3xl font-bold mb-4 text-center">
      × ×™×”×•×œ ×©×¨×©×¨×ª ×”×¡×™×‘×•×ª â›“ï¸â€ğŸ’¥
    </h1>
    <div
      id="status"
      class="mb-4 text-center text-sm text-gray-600 dark:text-gray-400 min-h-[1em]"
    >
      ×˜×•×¢×Ÿ...
    </div>

    <div class="mb-4 flex flex-wrap gap-2 justify-center">
      <button
        id="googleSignInBtn"
        class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
      >
        ×”×ª×—×‘×¨ ×‘×’×•×’×œ
      </button>
      <button
        id="newGroupBtn"
        class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 hidden"
      >
        â• ×”×•×¡×£ ×§×‘×•×¦×”
      </button>
      <button
        id="deleteGroupBtn"
        class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 hidden"
        disabled
      >
        ğŸ—‘ï¸ ××—×§ ×§×‘×•×¦×” × ×•×›×—×™×ª
      </button>
      <button
        id="importBtn"
        class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 hidden"
      >
        ğŸ“œ ×™×™×‘× ×§×‘×•×¦×•×ª
      </button>
    </div>

    <div
      id="importContainer"
      class="w-full max-w-xl p-4 border rounded-lg bg-gray-100 dark:bg-gray-800 mb-4"
    >
      <h3 class="text-lg font-semibold mb-2">×™×™×‘×•× ×§×‘×•×¦×•×ª ××˜×§×¡×˜</h3>
      <p class="text-sm mb-2 text-gray-600 dark:text-gray-400">
        ××‘× ×”: ×©×•×¨×ª × ×•×©×, ×©×•×¨×ª ×¨××ª ×§×•×©×™ (1-5), ×©×•×¨×•×ª ××©×¤×˜×™× (×¢× '*' ×œ× ×¢×•×œ), ×©×•×¨×”
        ×¨×™×§×” ×‘×™×Ÿ ×§×‘×•×¦×•×ª.
      </p>
      <textarea
        id="importText"
        rows="10"
        class="w-full p-2 border rounded bg-white dark:bg-gray-700 mb-2"
        placeholder="× ×•×©× ×”×§×‘×•×¦×” ×”×¨××©×•× ×”&#10;3&#10;××©×¤×˜ ×&#10;*××©×¤×˜ ×‘ (× ×¢×•×œ)&#10;&#10;× ×•×©× ×”×§×‘×•×¦×” ×”×©× ×™×™×”&#10;1&#10;*××©×¤×˜ ×’ (× ×¢×•×œ)&#10;××©×¤×˜ ×“"
      ></textarea>
      <button
        id="submitImportBtn"
        class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700"
      >
        ×‘×¦×¢ ×™×™×‘×•×
      </button>
      <div
        id="importStatus"
        class="mt-2 text-sm text-gray-600 dark:text-gray-400"
      ></div>
    </div>

    <div class="mb-4 w-full max-w-xl">
        <input
          type="search"
          id="searchInput"
          placeholder="×—×™×¤×•×© ×œ×¤×™ ×˜×§×¡×˜ ×‘× ×•×©× ××• ×‘××©×¤×˜×™×..."
          class="w-full p-2 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
          disabled
        />
      </div>
    <div class="mb-6 flex flex-wrap gap-4 justify-center items-center w-full max-w-xl">
      <label class="block whitespace-nowrap">
        ×¡×™× ×•×Ÿ × ×•×©×:
        <select id="topicFilter" class="p-1 border rounded bg-white dark:bg-gray-700" disabled>
          <option value="all">×”×›×œ</option>
          </select>
      </label>
      <label class="block whitespace-nowrap">
        ×¡×™× ×•×Ÿ ×¨××”:
        <select id="difficultyFilter" class="p-1 border rounded bg-white dark:bg-gray-700" disabled>
          <option value="all">×”×›×œ</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
        </select>
      </label>
      <button id="clearFiltersBtn" class="px-3 py-1 bg-gray-400 text-black rounded hover:bg-gray-500" disabled>× ×§×” ×¡×™× ×•× ×™×</button>
    </div>


    <div class="flex items-center mb-6 space-x-2 space-x-reverse">
      <button
        id="prevBtn"
        class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg"
        disabled
      >
        ×”×§×•×“×
      </button>
      <input
        id="groupInput"
        type="number"
        min="0"
        value="0"
        class="w-16 px-2 py-1 border rounded-lg text-center bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
        disabled
      />
      <span id="groupCount" class="text-gray-600 dark:text-gray-400">/ 0</span>
      <button
        id="nextBtn"
        class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg"
        disabled
      >
        ×”×‘×
      </button>
    </div>

    <div id="group-container" class="w-full max-w-xl min-h-[200px]">
        <p class="text-center text-gray-500 dark:text-gray-400">×˜×•×¢×Ÿ × ×ª×•× ×™×...</p>
    </div>

    <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
        onAuthStateChanged,
        GoogleAuthProvider,
        signInWithPopup,
        setPersistence,             // *** Added for persistence ***
        browserLocalPersistence     // *** Added for persistence ***
      } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-auth.js";
      import {
        getDatabase,
        ref,
        onValue,
        update,
        set,
        remove,
        child,
        get
      } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-database.js";

      // --- Firebase Configuration ---
      const firebaseConfig = {
        apiKey: "AIzaSyAGFC_TB8iEMvS2PyxeASj1HH4i66AW4UA", // Replace with your actual API key if needed
        authDomain: "trivbio.firebaseapp.com",
        databaseURL: "https://trivbio-default-rtdb.firebaseio.com",
        projectId: "trivbio",
        storageBucket: "trivbio.appspot.com",
        messagingSenderId: "1097087574583",
        appId: "1:1097087574583:web:b36c0441537a1f596215b2",
        measurementId: "G-ZY245YB23E",
      };
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app); // Get auth object
      const db = getDatabase(app);
      const groupsRef = ref(db, "collections/groups");

      // --- DOM Element References ---
      const statusEl = document.getElementById("status");
      const googleBtn = document.getElementById("googleSignInBtn");
      const newBtn = document.getElementById("newGroupBtn");
      const delBtn = document.getElementById("deleteGroupBtn");
      const importBtn = document.getElementById("importBtn");
      const importContainer = document.getElementById("importContainer");
      const importText = document.getElementById("importText");
      const submitImportBtn = document.getElementById("submitImportBtn");
      const importStatusEl = document.getElementById("importStatus");
      const container = document.getElementById("group-container");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const groupInp = document.getElementById("groupInput");
      const groupCountEl = document.getElementById("groupCount");
      const searchInput = document.getElementById('searchInput');
      const topicFilter = document.getElementById('topicFilter');
      const difficultyFilter = document.getElementById('difficultyFilter');
      const clearFiltersBtn = document.getElementById('clearFiltersBtn');

      // --- Global State Variables ---
      const TOPICS = ["×›×œ×œ×™", "×”×ª×", "×’×•×£ ×”××“×", "××§×•×œ×•×’×™×”", "××¢×‘×“×”"];
      let allGroups = [];
      let filteredGroups = [];
      let originalIdx = -1; // The originalIndex of the item being edited
      let filteredIdx = 0;
      let admin = false;
      let edit = false;
      let isAddingNewGroup = false;
      let newGroupDataBuffer = null;
      let currentAuthUser = null;
      let currentSearchTerm = '';
      let currentTopicFilter = 'all';
      let currentDifficultyFilter = 'all';
      let focusOnOriginalIndexAfterUpdate = -1; // Flag to restore view after edit

      // --- Initialization ---
      const topicOptionsHTML = TOPICS.map(t => `<option value="${t}">${t}</option>`).join('');
      topicFilter.innerHTML += topicOptionsHTML;

      // --- Authentication Setup ---
       function initializeAuthListener() {
           onAuthStateChanged(auth, (u) => {
               currentAuthUser = u;
               if (u) {
                   const isGoogleSignIn = u.providerData.some((p) => p.providerId === "google.com");
                   if (isGoogleSignIn) {
                       googleBtn.classList.add("hidden");
                       statusEl.innerText = `××—×•×‘×¨: ${u.email}`;
                       checkAdminStatus(u.uid); // Checks admin then calls listenForGroups
                   } else {
                       // Still signed in, but anonymously
                       googleBtn.classList.remove("hidden");
                       statusEl.innerText = "××—×•×‘×¨ ×× ×•× ×™××™×ª. ×”×ª×—×‘×¨ ×¢× ×’×•×’×œ ×œ× ×™×”×•×œ.";
                       admin = false; // Anonymous is not admin
                       updateAdminUI();
                       listenForGroups(); // Listen for data as anonymous user
                   }
               } else {
                   // Not signed in
                   googleBtn.classList.remove("hidden");
                   statusEl.innerText = "××™× ×š ××—×•×‘×¨. ×”×ª×—×‘×¨ ×¢× ×’×•×’×œ ×œ× ×™×”×•×œ.";
                   admin = false;
                   updateAdminUI();
                   allGroups = []; // Clear data
                   edit = false;
                   isAddingNewGroup = false;
                   applyFiltersAndSearch(); // Render empty state
                   // Optional: Trigger initial anonymous sign-in again if desired
                   // signInAnonymously(auth).catch(/* ... */);
               }
           });
       }

      // *** Set persistence BEFORE initializing the listener ***
      setPersistence(auth, browserLocalPersistence)
          .then(() => {
              console.log("Firebase Auth persistence set to local.");
              // Now that persistence is set, initialize the auth state listener
              initializeAuthListener();
          })
          .catch((error) => {
              console.error("Error setting Firebase Auth persistence:", error);
              statusEl.innerText = "×©×’×™××” ×‘×”×’×“×¨×ª ×©××™×¨×ª ×”×ª×—×‘×¨×•×ª. ×™×™×ª×›×Ÿ ×©×ª×¦×˜×¨×š ×œ×”×ª×—×‘×¨ ×©×•×‘.";
              // Initialize listener anyway, it will likely show "not signed in" state
              initializeAuthListener();
          });

      // --- Rest of the Auth and UI Logic ---
      const provider = new GoogleAuthProvider();
      googleBtn.onclick = () => signInWithPopup(auth, provider).catch((e) => (statusEl.innerText = "×©×’×™××ª ×”×ª×—×‘×¨×•×ª ×’×•×’×œ: " + e.message));

      function checkAdminStatus(uid) {
           const adminRef = ref(db, `admins/${uid}`);
           get(adminRef).then((snapshot) => { // Use get() for one-time check
               admin = snapshot.exists() && snapshot.val() === true;
               updateAdminUI();
               if (!admin && statusEl.innerText.startsWith("××—×•×‘×¨:")) { statusEl.innerText += " (×œ× ×× ×”×œ)"; }
               listenForGroups(); // Listen *after* confirming admin status
           }).catch(error => {
                console.error("Error checking admin status:", error);
                admin = false; updateAdminUI(); listenForGroups(); // Assume not admin, but still listen
           });
      }

      function updateAdminUI() { if (admin) { newBtn.classList.remove("hidden"); delBtn.classList.remove("hidden"); importBtn.classList.remove("hidden"); } else { newBtn.classList.add("hidden"); delBtn.classList.add("hidden"); importBtn.classList.add("hidden"); importContainer.classList.remove("visible"); if (edit) { cancelEditOrAdd(); } } render(); updateNav(); }

      // --- Data Handling ---
      function listenForGroups() {
        onValue(groupsRef, (snap) => {
          const groupsData = snap.val(); let processedGroups = [];
          if (groupsData) { if (Array.isArray(groupsData)) { processedGroups = groupsData.map((group, index) => group && typeof index === 'number' && !isNaN(index) ? { ...group, originalIndex: index } : null).filter(group => group !== null); } else if (typeof groupsData === 'object') { processedGroups = Object.entries(groupsData).map(([key, group]) => { const index = parseInt(key, 10); return (group && !isNaN(index)) ? { ...group, originalIndex: index } : null; }).filter(group => group !== null).sort((a, b) => a.originalIndex - b.originalIndex); } }
          allGroups = processedGroups;

          if ((edit || isAddingNewGroup) && allGroups.length === 0) { cancelEditOrAdd(); }

          applyFiltersAndSearch(); // Apply filters first

          // --- Focus/Restore Logic ---
          if (focusOnOriginalIndexAfterUpdate !== -1) { // Priority: Focus after update
              const targetFilteredIndex = filteredGroups.findIndex(g => g.originalIndex === focusOnOriginalIndexAfterUpdate);
              if (targetFilteredIndex !== -1) { filteredIdx = targetFilteredIndex; }
              else { filteredIdx = Math.max(0, filteredGroups.length - 1); if (filteredGroups.length === 0) filteredIdx = 0; }
              console.log(`Listener: Focused/Reset after update. Target Orig Idx: ${focusOnOriginalIndexAfterUpdate}, New Filt Idx: ${filteredIdx}`);
              focusOnOriginalIndexAfterUpdate = -1; // Reset flag
          } else if (!edit) { // General restoration logic (only if not editing and not focusing)
               let currentlyViewedOriginalIndex = -1;
               // Ensure filteredIdx is valid before accessing filteredGroups[filteredIdx]
               if (filteredGroups.length > 0 && filteredIdx >= 0 && filteredIdx < filteredGroups.length && filteredGroups[filteredIdx]?.originalIndex !== undefined) {
                   currentlyViewedOriginalIndex = filteredGroups[filteredIdx].originalIndex;
               }
              if (currentlyViewedOriginalIndex !== -1) {
                  const restoredFilteredIndex = filteredGroups.findIndex(g => g.originalIndex === currentlyViewedOriginalIndex);
                  if (restoredFilteredIndex !== -1) { filteredIdx = restoredFilteredIndex; } // Restore
                  else { filteredIdx = Math.max(0, filteredGroups.length - 1); if (filteredGroups.length === 0) filteredIdx = 0; } // Default if not found
              } else { // Default if nothing was viewed or index was invalid
                   filteredIdx = Math.max(0, filteredGroups.length - 1); if (filteredGroups.length === 0) filteredIdx = 0;
              }
          }
          // --- End Focus/Restore Logic ---

          updateStatusMessage(); render(); updateNav();

        }, (error) => {
          console.error("Error fetching groups:", error); statusEl.innerText = "×©×’×™××” ×‘×§×¨×™××ª × ×ª×•× ×™×."; allGroups = []; edit = false; isAddingNewGroup = false; applyFiltersAndSearch(); updateStatusMessage(); render(); updateNav();
        });
      }

       function updateStatusMessage() { if (edit) { statusEl.innerText = isAddingNewGroup ? '××™×œ×•×™ ×¤×¨×˜×™ ×§×‘×•×¦×” ×—×“×©×”...' : `×¢×¨×™×›×ª ×§×‘×•×¦×”...`; return; } if (allGroups.length === 0) { statusEl.innerText = admin ? "××™×Ÿ ×§×‘×•×¦×•×ª. ×”×•×¡×£ ××• ×™×™×‘×." : "××™×Ÿ ×§×‘×•×¦×•×ª ×œ×”×¦×’×”."; } else if (filteredGroups.length === 0) { statusEl.innerText = `×œ× × ××¦××• ×§×‘×•×¦×•×ª ×‘×¡×™× ×•×Ÿ ××ª×•×š ${allGroups.length}.`; } else { statusEl.innerText = `××¦×™×’ ${filteredGroups.length} ××ª×•×š ${allGroups.length} (${filteredIdx + 1}/${filteredGroups.length})`; } }

      // --- Filtering and Searching ---
      function applyFiltersAndSearch() { const searchTerm = currentSearchTerm.toLowerCase(); filteredGroups = allGroups.filter((group) => { if (!group || !group.sentences || !Array.isArray(group.sentences) || typeof group.originalIndex !== 'number') { return false; } const diffMatch = currentDifficultyFilter === 'all' || group.difficulty == currentDifficultyFilter; const topicMatch = currentTopicFilter === 'all' || (group.topic || '×›×œ×œ×™') === currentTopicFilter; const searchMatch = searchTerm === '' || ((group.topic || '').toLowerCase().includes(searchTerm)) || group.sentences.some(s => s && s.text && s.text.toLowerCase().includes(searchTerm)); return diffMatch && topicMatch && searchMatch; }); }

      // --- Event Listeners for Search/Filter ---
      searchInput.addEventListener('input', () => { if (edit) return; currentSearchTerm = searchInput.value; applyFiltersAndSearch(); filteredIdx = 0; render(); updateNav(); updateStatusMessage(); });
      topicFilter.addEventListener('change', () => { if (edit) return; currentTopicFilter = topicFilter.value; applyFiltersAndSearch(); filteredIdx = 0; render(); updateNav(); updateStatusMessage(); });
      difficultyFilter.addEventListener('change', () => { if (edit) return; currentDifficultyFilter = difficultyFilter.value; applyFiltersAndSearch(); filteredIdx = 0; render(); updateNav(); updateStatusMessage(); });
      clearFiltersBtn.addEventListener('click', () => { if (edit) return; searchInput.value = ''; topicFilter.value = 'all'; difficultyFilter.value = 'all'; currentSearchTerm = ''; currentTopicFilter = 'all'; currentDifficultyFilter = 'all'; applyFiltersAndSearch(); filteredIdx = 0; render(); updateNav(); updateStatusMessage(); });

      // --- Group Actions ---
      newBtn.onclick = () => { if (!admin || edit) return; edit = true; isAddingNewGroup = true; newGroupDataBuffer = { difficulty: 1, topic: "×›×œ×œ×™", sentences: [{ text: "", movable: true }] }; originalIdx = -1; render(); updateNav(); updateStatusMessage(); };
      delBtn.onclick = () => { if (!admin || edit || filteredGroups.length === 0) return; const groupToDelete = filteredGroups[filteredIdx]; if (!groupToDelete || typeof groupToDelete.originalIndex !== 'number') { statusEl.innerText = "×©×’×™××” ×‘×–×™×”×•×™ ×§×‘×•×¦×”."; return; } const idxToDelete = groupToDelete.originalIndex; if (!confirm(`×œ××—×•×§ ××ª ×§×‘×•×¦×” "${groupToDelete.topic || '×›×œ×œ×™'} - ×¨××” ${groupToDelete.difficulty}"?`)) return; statusEl.innerText = "××•×—×§..."; remove(ref(db, `collections/groups/${idxToDelete}`)).then(() => { statusEl.innerText = "× ××—×§"; }).catch((e) => { statusEl.innerText = "×©×’×™××” ×‘××—×™×§×”: " + e.message; }); };

      // --- Import Logic ---
      importBtn.onclick = () => { if (!admin || edit) return; importContainer.classList.toggle("visible"); importStatusEl.innerText = ""; importText.value = ""; if (importContainer.classList.contains("visible") && edit) { cancelEditOrAdd(); } };
      submitImportBtn.onclick = () => { if (!admin) return; const text = importText.value.trim(); if (!text) { importStatusEl.innerText = "×ª×™×‘×ª ×˜×§×¡×˜ ×¨×™×§×”."; return; } importStatusEl.innerText = "××¢×‘×“..."; const parsed = parseImportText(text); if (parsed.error) { importStatusEl.innerText = `×©×’×™××ª × ×™×ª×•×—: ${parsed.error}`; return; } if (parsed.groups.length === 0) { importStatusEl.innerText = "×œ× × ××¦××• ×§×‘×•×¦×•×ª ×ª×§×™× ×•×ª."; return; } importGroupsToFirebase(parsed.groups); };
      function parseImportText(text) { const blocks = text.split(/\n\s*\n/); const newGroups = []; let error = null; blocks.forEach((block, blockIndex) => { if (error) return; const lines = block.trim().split("\n").map(l => l.trim()).filter(l => l); if (lines.length < 3) { if (lines.length > 0) { error = `×‘×œ×•×§ ${blockIndex + 1}: ×—×¡×¨ × ×•×©×/×¨××”/××©×¤×˜.`; } return; } const topicLine = lines[0]; const topic = TOPICS.includes(topicLine) ? topicLine : "×›×œ×œ×™"; let difficulty = 1; const difficultyLine = lines[1]; const parsedDifficulty = parseInt(difficultyLine, 10); if (!isNaN(parsedDifficulty) && parsedDifficulty >= 1 && parsedDifficulty <= 5) { difficulty = parsedDifficulty; } else { console.warn(`Invalid difficulty '${difficultyLine}'.`); } const sentences = lines.slice(2).map(line => { const isLocked = line.startsWith("*"); const text = isLocked ? line.substring(1).trim() : line; if (!text) return null; return { text: text, movable: !isLocked }; }).filter(s => s !== null); if (sentences.length === 0) { error = `×‘×œ×•×§ ${blockIndex + 1} ("${topicLine}"): ××™×Ÿ ××©×¤×˜×™× ×ª×§×™× ×™×.`; return; } newGroups.push({ difficulty: difficulty, topic: topic, sentences: sentences }); }); return { groups: newGroups, error: error }; }
      async function importGroupsToFirebase(parsedGroups) { if (!admin) return; importStatusEl.innerText = `××™×™×‘× ${parsedGroups.length}...`; try { const validIndices = allGroups.map(g => g.originalIndex).filter(idx => typeof idx === 'number' && !isNaN(idx)); const nextIdx = validIndices.length > 0 ? Math.max(...validIndices) + 1 : 0; if (isNaN(nextIdx)) { throw new Error("Could not determine next index."); } const updates = {}; parsedGroups.forEach((group, i) => { const newIdx = nextIdx + i; updates[newIdx] = { ...group, originalIndex: newIdx }; }); if (Object.keys(updates).length > 0) { await update(ref(db, 'collections/groups'), updates); importStatusEl.innerText = `×™×™×‘×•× ×”×•×©×œ×!`; importText.value = ""; importContainer.classList.remove("visible"); } else { importStatusEl.innerText = "×œ× × ××¦××• ×§×‘×•×¦×•×ª ×œ×™×™×‘×."; } } catch (e) { console.error("Import error:", e); importStatusEl.innerText = "×©×’×™××” ×‘×™×™×‘×•×: " + e.message; } }

      // --- Rendering Logic ---
      const rowHTML = (text, locked) => ` <div class="sentence-row flex items-center space-x-2 space-x-reverse mb-2"><input type="text" value="${text || ''}" class="sentence-input flex-1 p-2 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100" placeholder="×”×–×Ÿ ××©×¤×˜ ×›××Ÿ" /><label class="inline-flex items-center space-x-1 space-x-reverse" title="× ×¢×œ ××©×¤×˜"><input type="checkbox" ${locked ? "checked" : ""} class="lock-checkbox h-5 w-5 accent-blue-500" /><span>ğŸ”’</span></label><button type="button" class="removeSentence text-red-500 hover:text-red-700 font-bold text-lg" title="××—×§ ××©×¤×˜">âœ–ï¸</button></div>`;
      function view(g) { if (!g || typeof g.originalIndex !== 'number') return '<p>×©×’×™××” ×‘× ×ª×•× ×™×.</p>'; const topic = g.topic || '×›×œ×œ×™'; const diff = g.difficulty || '?'; const title = `${topic} - ×¨××” ${diff}`; const editBtn = admin ? `<button data-original-idx="${g.originalIndex}" id="editBtn" class="absolute top-2 left-2 text-gray-500 hover:text-gray-800 dark:hover:text-gray-200 text-xl" title="×¢×¨×•×š">âœï¸</button>` : ''; return `<div class="border rounded-2xl shadow-lg p-4 bg-gray-50 dark:bg-gray-800 relative">${editBtn}<h2 class="text-2xl font-semibold mb-4">${title}</h2><h3 class="text-lg font-semibold mb-2">××©×¤×˜×™×:</h3><ol class="list-decimal list-outside mr-5 space-y-1"> ${ (g.sentences && Array.isArray(g.sentences)) ? g.sentences.map(s => `<li>${s.text || '(×¨×™×§)'}${!s.movable ? ' <span class="text-sm text-green-600 dark:text-green-400" title="× ×¢×•×œ">ğŸ”’</span>' : ''}</li>`).join('') : '<li>××™×Ÿ ××©×¤×˜×™×.</li>' }</ol></div>`; }
      function editForm(g) { const data = isAddingNewGroup ? newGroupDataBuffer : g; if (!data) { return '<p class="text-red-500">×©×’×™××” ×‘×”×¦×’×ª ×˜×•×¤×¡.</p>'; } const rows = (data.sentences || []).map(s => rowHTML(s.text || '', !s.movable)).join(""); const topic = data.topic || "×›×œ×œ×™"; const title = isAddingNewGroup ? "×”×•×¡×¤×ª ×§×‘×•×¦×” ×—×“×©×”" : `×¢×¨×™×›×ª ×§×‘×•×¦×”`; return `<div class="border rounded-2xl shadow-lg p-4 bg-gray-50 dark:bg-gray-800"><h2 class="text-2xl font-semibold mb-2">${title}</h2><form id="editForm" class="space-y-3"><div class="flex flex-wrap gap-4 items-center mb-4"><label class="block">×¨××ª ×§×•×©×™: <input id="diffInput" type="number" value="${data.difficulty || 1}" min="1" max="5" class="p-1 border rounded bg-white dark:bg-gray-700 w-16 text-gray-900 dark:text-gray-100" /></label><label class="block">× ×•×©×: <select id="topicInput" class="p-1 border rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">${TOPICS.map(t => `<option value="${t}" ${t === topic ? "selected" : ""}>${t}</option>`).join("")}</select></label></div><div id="sentences-container"><h3 class="text-lg font-semibold mb-2">××©×¤×˜×™×:</h3>${rows}</div><button type="button" id="addSentence" class="mt-2 px-3 py-1 bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 rounded text-gray-900 dark:text-gray-100">â• ×”×•×¡×£ ××©×¤×˜</button><div class="flex justify-between mt-4"><button type="button" id="cancelBtn" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">×‘×™×˜×•×œ</button><button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">×©××•×¨ ×•×¡×’×•×¨</button></div></form></div>`; }
      function render() { container.innerHTML = ''; if (edit) { if (isAddingNewGroup) { container.innerHTML = editForm(null); } else { const groupToEdit = allGroups.find(g => g.originalIndex === originalIdx); if (groupToEdit) { container.innerHTML = editForm(groupToEdit); } else { console.error(`Render error: Group ${originalIdx} not found.`); statusEl.innerText = '×©×’×™××”: ×§×‘×•×¦×” ×œ×¢×¨×™×›×” ×œ× × ××¦××”.'; cancelEditOrAdd(); } } } else { if (filteredGroups.length > 0 && filteredIdx < filteredGroups.length) { const groupToView = filteredGroups[filteredIdx]; if (groupToView && typeof groupToView.originalIndex === 'number') { container.innerHTML = view(groupToView); } else { console.error("Render view error: Invalid group data", filteredIdx, groupToView); container.innerHTML = '<p class="text-red-500">×©×’×™××” ×‘×”×¦×’×”.</p>'; } } else { const hasFilters = currentSearchTerm || currentTopicFilter !== 'all' || currentDifficultyFilter !== 'all'; container.innerHTML = allGroups.length === 0 ? (admin ? '<p>××™×Ÿ ×§×‘×•×¦×•×ª. ×”×•×¡×£ ××• ×™×™×‘×.</p>' : '<p>××™×Ÿ ×§×‘×•×¦×•×ª ×œ×”×¦×’×”.</p>') : (hasFilters ? '<p>×œ× × ××¦××• ×§×‘×•×¦×•×ª ×‘×¡×™× ×•×Ÿ ×–×”.</p>' : '<p>×˜×•×¢×Ÿ...</p>'); } } }

      // --- Navigation ---
      function updateNav() { const totalFiltered = filteredGroups.length; const displayTotal = totalFiltered; const displayIdx = filteredIdx; const disableNav = edit || totalFiltered === 0; const disableFilters = edit; prevBtn.disabled = disableNav || displayIdx <= 0; nextBtn.disabled = disableNav || displayIdx >= displayTotal - 1; groupInp.disabled = disableNav; searchInput.disabled = disableFilters; topicFilter.disabled = disableFilters; difficultyFilter.disabled = disableFilters; clearFiltersBtn.disabled = disableFilters; groupInp.value = totalFiltered === 0 ? 0 : displayIdx + 1; groupInp.max = displayTotal > 0 ? displayTotal : 1; groupInp.min = totalFiltered > 0 ? 1 : 0; groupCountEl.innerText = `/ ${displayTotal}`; delBtn.disabled = !admin || edit || totalFiltered === 0; newBtn.disabled = !admin || edit; importBtn.disabled = !admin || edit; }
      prevBtn.onclick = () => { if (!edit && filteredIdx > 0) { filteredIdx--; render(); updateNav(); updateStatusMessage(); } };
      nextBtn.onclick = () => { if (!edit && filteredIdx < filteredGroups.length - 1) { filteredIdx++; render(); updateNav(); updateStatusMessage(); } };
      groupInp.onchange = (e) => { if (edit) return; const v = +e.target.value - 1; if (v >= 0 && v < filteredGroups.length) { filteredIdx = v; render(); updateNav(); updateStatusMessage();} else { e.target.value = filteredGroups.length > 0 ? filteredIdx + 1 : 0; } };

      // --- Edit Form Event Listeners ---
       function cancelEditOrAdd() { const wasAdding = isAddingNewGroup; edit = false; isAddingNewGroup = false; newGroupDataBuffer = null; originalIdx = -1; focusOnOriginalIndexAfterUpdate = -1; statusEl.innerText = wasAdding ? "×”×•×¡×¤×” ×‘×•×˜×œ×”" : "×¢×¨×™×›×” ×‘×•×˜×œ×”"; render(); updateNav(); updateStatusMessage(); }
      container.addEventListener("click", (e) => {
        if (e.target.id === "editBtn") { if (!admin || edit) return; const idxStr = e.target.getAttribute('data-original-idx'); const idx = parseInt(idxStr, 10); if (isNaN(idx)) { statusEl.innerText = "×©×’×™××” ×‘××™× ×“×§×¡."; return; } const exists = allGroups.some(g => g.originalIndex === idx); if (exists) { originalIdx = idx; edit = true; isAddingNewGroup = false; render(); updateNav(); updateStatusMessage(); } else { statusEl.innerText = "×©×’×™××”: ×œ× × ×™×ª×Ÿ ×œ××¦×•× ×§×‘×•×¦×”."; } return; }
        if (e.target.id === "cancelBtn") { cancelEditOrAdd(); return; }
        if (e.target.id === "addSentence") { const c = document.getElementById("sentences-container"); if (c) { const div = document.createElement("div"); div.innerHTML = rowHTML("", false); const row = div.firstElementChild; if (row) { c.appendChild(row); row.querySelector('input[type="text"]')?.focus(); } } return; }
        if (e.target.classList.contains("removeSentence")) { const row = e.target.closest(".sentence-row"); const c = row?.closest("#sentences-container"); if (row && c) { if (c.querySelectorAll(".sentence-row").length <= 1) { statusEl.innerText = "×—×•×‘×” ×œ×”×©××™×¨ ××©×¤×˜ ××—×“."; row.animate([{ backgroundColor: "rgba(255,100,100,0.3)" }, { backgroundColor: "transparent" }], { duration: 600 }); return; } row.remove(); } return; }
      });

      // --- Edit Form Submit Handler ---
      container.addEventListener("submit", (e) => {
        e.preventDefault(); if (!admin || !edit) return; const form = e.target; if (form.id !== "editForm") return;
        statusEl.innerText = "×©×•××¨...";
        const diffInput = document.getElementById("diffInput"); const topicInput = document.getElementById("topicInput");
        const difficulty = diffInput ? parseInt(diffInput.value) || 1 : 1; const topic = topicInput ? topicInput.value : "×›×œ×œ×™";
        const rows = [...form.querySelectorAll(".sentence-row")]; let errorOccurred = false;
        const sentences = rows.map((row) => { const textInput = row.querySelector(".sentence-input"); const lockCheckbox = row.querySelector(".lock-checkbox"); if (!textInput || !lockCheckbox) { if (!errorOccurred) { statusEl.innerText = "×©×’×™××” ×‘××‘× ×” ×”×©×•×¨×”."; errorOccurred = true; } return null; } const textValue = textInput.value.trim(); if (!textValue) { return null; } return { text: textValue, movable: !lockCheckbox.checked }; }).filter(s => s !== null);
        if (errorOccurred) return; if (sentences.length === 0) { statusEl.innerText = "×—×•×‘×” ×œ×”×–×™×Ÿ ×œ×¤×—×•×ª ××©×¤×˜ ××—×“."; return; }

        const finalGroupData = { difficulty, topic, sentences }; const wasAdding = isAddingNewGroup;
        let savePromise; let savePath; let indexToSaveAt;

        try {
            if (wasAdding) {
                const validIndices = allGroups.map(g => g.originalIndex).filter(idx => typeof idx === 'number' && !isNaN(idx)); indexToSaveAt = validIndices.length > 0 ? Math.max(...validIndices) + 1 : 0;
                if (isNaN(indexToSaveAt)) { throw new Error("Failed to calculate next index."); }
                savePath = ref(db, `collections/groups/${indexToSaveAt}`); finalGroupData.originalIndex = indexToSaveAt;
                savePromise = set(savePath, finalGroupData);
            } else { // Updating
                if (typeof originalIdx !== 'number' || isNaN(originalIdx) || originalIdx < 0) { throw new Error(`Invalid original index for update: ${originalIdx}`); }
                indexToSaveAt = originalIdx; savePath = ref(db, `collections/groups/${indexToSaveAt}`);
                finalGroupData.originalIndex = indexToSaveAt;
                savePromise = update(savePath, finalGroupData); // Use update
            }
            console.log(`Attempting to save to index: ${indexToSaveAt}`);

            savePromise
              .then(() => {
                statusEl.innerText = wasAdding ? "×§×‘×•×¦×” ×—×“×©×” × ×©××¨×”" : "× ×©××¨";
                const savedOriginalIndex = indexToSaveAt;
                if (!wasAdding) { // Set focus flag only when updating
                    focusOnOriginalIndexAfterUpdate = savedOriginalIndex;
                    console.log(`Set focus flag for original index: ${focusOnOriginalIndexAfterUpdate}`);
                }
                cancelEditOrAdd(); // Exit edit mode *after* potentially setting flag
              })
              .catch((e) => { console.error("Save promise error:", e); statusEl.innerText = "×©×’×™××” ×‘×©××™×¨×”: " + e.message; });

        } catch (error) {
             console.error("Error preparing save:", error); statusEl.innerText = "×©×’×™××” ×‘×”×›× ×” ×œ×©××™×¨×”: " + error.message;
        }
      }); // End of Submit Handler
    </script>
  </body>
</html>